<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TaxoConf Task Workspace</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-1: #f8f2e7;
      --bg-2: #ecf5f3;
      --ink: #1c2a38;
      --ink-soft: #4e6073;
      --panel: rgba(255, 255, 255, 0.9);
      --line: #d9e2e0;
      --accent: #138f8b;
      --accent-strong: #0f7673;
      --accent-warm: #e06a2d;
      --accent-muted: #8ea65f;
      --danger: #b53d33;
      --shadow: 0 14px 34px rgba(24, 48, 67, 0.12);
      --radius: 16px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Space Grotesk", "Trebuchet MS", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 8% 0%, rgba(224, 106, 45, 0.18), transparent 42%),
        radial-gradient(circle at 88% 14%, rgba(19, 143, 139, 0.2), transparent 40%),
        linear-gradient(165deg, var(--bg-1), var(--bg-2) 54%, #fbefe0 100%);
    }

    .app {
      width: min(1520px, 96vw);
      margin: 16px auto 24px;
      display: grid;
      grid-template-columns: 280px minmax(0, 1fr);
      gap: 14px;
    }

    .panel {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid rgba(255, 255, 255, 0.78);
      box-shadow: var(--shadow);
    }

    .sidebar {
      padding: 14px;
      position: sticky;
      top: 12px;
      height: fit-content;
      max-height: calc(100vh - 24px);
      overflow: auto;
    }

    .brand {
      padding: 8px 8px 12px;
      border-bottom: 1px solid #e7f0ee;
      margin-bottom: 12px;
    }

    .brand h1 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: -0.02em;
    }

    .brand p {
      margin: 4px 0 0;
      font-size: 0.78rem;
      color: var(--ink-soft);
      line-height: 1.35;
    }

    .nav-list {
      display: grid;
      gap: 8px;
    }

    .nav-btn {
      text-align: left;
      border: 1px solid #d7e5e2;
      border-radius: 12px;
      background: #f3faf8;
      color: #2e4f62;
      padding: 10px 12px;
      font-family: inherit;
      font-size: 0.86rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .nav-btn.is-active {
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #fff;
      border-color: transparent;
      box-shadow: 0 7px 16px rgba(15, 118, 115, 0.24);
    }

    .sidebar-meta {
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px dashed #d3e3df;
      font-size: 0.74rem;
      color: var(--ink-soft);
    }

    .content {
      display: grid;
      gap: 14px;
    }

    .task-view {
      display: none;
      gap: 14px;
    }

    .task-view.is-active {
      display: grid;
      animation: reveal 0.2s ease;
    }

    @keyframes reveal {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .setup-panel,
    .result-panel {
      padding: 14px;
    }

    .setup-panel h2,
    .result-panel h2 {
      margin: 0 0 10px;
      font-size: 1.02rem;
      letter-spacing: -0.01em;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items: start;
    }

    .grid-3 {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    .control-card {
      border: 1px solid #e5efec;
      background: #fff;
      border-radius: 12px;
      padding: 10px;
    }

    .control-group {
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 0.8rem;
      color: var(--ink-soft);
      font-weight: 600;
    }

    .control-value {
      font-family: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
      color: #245c61;
      font-size: 0.75rem;
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      color: var(--ink);
      font-family: inherit;
      font-size: 0.86rem;
      padding: 8px 9px;
    }

    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }

    .toggle-row {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 0.82rem;
      color: #3f5a6c;
      margin: 5px 0;
    }

    .btn-row {
      display: grid;
      gap: 8px;
    }

    button {
      border: 0;
      border-radius: 10px;
      padding: 10px 12px;
      font-family: inherit;
      font-size: 0.84rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.14s ease;
    }

    button:active {
      transform: translateY(1px);
    }

    .btn-primary {
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #fff;
      box-shadow: 0 7px 18px rgba(15, 118, 115, 0.24);
    }

    .btn-secondary {
      background: linear-gradient(120deg, #f8eee7, #f5dfd0);
      color: #8a4824;
      border: 1px solid rgba(224, 106, 45, 0.21);
    }

    .btn-muted {
      background: linear-gradient(120deg, #edf6f3, #e4efec);
      color: #335566;
      border: 1px solid #d7e6e2;
    }

    .tiny {
      font-size: 0.74rem;
      color: var(--ink-soft);
      line-height: 1.35;
    }

    .summary {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
      margin-bottom: 10px;
    }

    .metric {
      border: 1px solid #e7efed;
      background: #fff;
      border-radius: 10px;
      padding: 9px;
    }

    .metric .label {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #5d7081;
      margin-bottom: 3px;
    }

    .metric .value {
      font-size: 1.05rem;
      font-weight: 700;
    }

    .table-wrap {
      overflow: auto;
      border: 1px solid #e7eeec;
      border-radius: 10px;
      background: #fff;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 760px;
      font-size: 0.79rem;
    }

    th,
    td {
      border-bottom: 1px solid #eef2f1;
      padding: 8px 9px;
      text-align: left;
      vertical-align: top;
    }

    th {
      background: #f6fbfa;
      color: #4c6375;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    tbody tr.clickable { cursor: pointer; }
    tbody tr.clickable:hover { background: #f6fbfa; }
    tbody tr.selected { background: #eaf8f5; }

    .badge {
      display: inline-block;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 700;
      border: 1px solid transparent;
      white-space: nowrap;
    }

    .badge-ok {
      color: #0f6b68;
      background: rgba(19, 143, 139, 0.13);
      border-color: rgba(19, 143, 139, 0.26);
    }

    .badge-warn {
      color: #8f4f27;
      background: rgba(224, 106, 45, 0.14);
      border-color: rgba(224, 106, 45, 0.28);
    }

    .badge-danger {
      color: #91352f;
      background: rgba(181, 61, 51, 0.12);
      border-color: rgba(181, 61, 51, 0.23);
    }

    .badge-muted {
      color: #395c6f;
      background: #eef5f2;
      border-color: #d8e7e3;
    }

    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .small-tab {
      border: 1px solid #d8e7e3;
      border-radius: 999px;
      background: #eef7f5;
      color: #33596a;
      padding: 6px 10px;
      font-size: 0.76rem;
      font-weight: 700;
      cursor: pointer;
    }

    .small-tab.is-active {
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #fff;
      border-color: transparent;
    }

    .result-split {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 12px;
      align-items: start;
    }

    .detail-card,
    .gap-card,
    .list-card {
      border: 1px solid #e5efec;
      background: #fff;
      border-radius: 12px;
      padding: 10px;
    }

    .detail-card h3,
    .gap-card h3,
    .list-card h3 {
      margin: 0 0 8px;
      font-size: 0.9rem;
      color: #304b5c;
    }

    .bars {
      display: grid;
      gap: 7px;
    }

    .bar-row {
      display: grid;
      grid-template-columns: minmax(120px, 1fr) minmax(130px, 2fr) 56px;
      gap: 7px;
      align-items: center;
      font-size: 0.76rem;
    }

    .bar-track {
      height: 9px;
      border-radius: 999px;
      background: #edf4f2;
      border: 1px solid #dce9e5;
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #57b9b5);
    }

    .bar-fill.warm {
      background: linear-gradient(90deg, var(--accent-warm), #eba15f);
    }

    .bar-fill.muted {
      background: linear-gradient(90deg, #93b76a, #aacb81);
    }

    .mono {
      font-family: "IBM Plex Mono", "SFMono-Regular", Consolas, monospace;
      font-size: 0.74rem;
    }

    .schedule-table {
      overflow: auto;
      border: 1px solid #e7efed;
      border-radius: 10px;
      background: #fff;
      margin-bottom: 10px;
    }

    .schedule-table table {
      min-width: 680px;
    }

    .schedule-cell {
      min-height: 74px;
      display: grid;
      gap: 5px;
    }

    .pill {
      display: inline-block;
      border: 1px solid #d8e7e3;
      border-radius: 999px;
      background: #eef7f5;
      padding: 3px 7px;
      font-size: 0.7rem;
      margin-right: 5px;
      margin-top: 4px;
    }

    .poster-grid {
      border: 1px solid #e7efed;
      border-radius: 10px;
      overflow: auto;
      background: #fff;
      margin-bottom: 10px;
    }

    .poster-grid table {
      min-width: 620px;
    }

    .poster-cell {
      min-height: 70px;
      font-size: 0.76rem;
    }

    .editor-table {
      overflow: auto;
      border: 1px solid #e7efed;
      border-radius: 10px;
      background: #fff;
      margin-top: 10px;
    }

    .editor-table table {
      min-width: 760px;
    }

    @media (max-width: 1160px) {
      .app {
        grid-template-columns: 1fr;
      }

      .sidebar {
        position: static;
        max-height: none;
      }
    }

    @media (max-width: 920px) {
      .grid-2,
      .grid-3,
      .result-split {
        grid-template-columns: 1fr;
      }

      .summary {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 620px) {
      .summary {
        grid-template-columns: 1fr;
      }

      .bar-row {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="panel sidebar">
      <div class="brand">
        <h1>TaxoConf Workspace</h1>
        <p>Switch tasks in this navigation drawer. Each task has its own setup panel and result panel.</p>
      </div>
      <div class="nav-list" role="navigation" aria-label="Task Navigation">
        <button class="nav-btn is-active" data-task="assignment" type="button">Paper Assignment</button>
        <button class="nav-btn" data-task="discovery" type="button">PC Member Discovery</button>
        <button class="nav-btn" data-task="oral" type="button">Oral Session Organization</button>
        <button class="nav-btn" data-task="poster" type="button">Poster Session Organization</button>
      </div>
      <div class="sidebar-meta">
        <div>Core metric: weighted Tree-Wasserstein</div>
        <div>Synthesized defaults loaded on startup.</div>
      </div>
    </aside>

    <main class="content">
      <section class="task-view is-active" id="task-assignment">
        <section class="panel setup-panel">
          <h2>Setup Panel: Paper Assignment</h2>
          <div class="grid-3">
            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Upload Inputs</h3>
              <div class="btn-row">
                <button id="uploadSubmissionBtn" class="btn-secondary" type="button">Upload Submissions JSON</button>
                <input id="submissionFileInput" type="file" accept=".json" style="display:none">
                <button id="uploadPcBtn" class="btn-secondary" type="button">Upload PC Members JSON</button>
                <input id="pcFileInput" type="file" accept=".json" style="display:none">
                <button id="uploadCoiBtn" class="btn-secondary" type="button">Upload COI Matrix JSON</button>
                <input id="coiFileInput" type="file" accept=".json" style="display:none">
              </div>
              <div id="assignmentUploadStatus" class="tiny" style="margin-top:8px"></div>
            </div>

            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Parameters</h3>
              <div class="control-group">
                <span class="control-label">Reviewer Workload (papers/member)</span>
                <input id="workloadInput" type="number" min="1" step="1" value="4">
              </div>
              <div class="control-group">
                <span class="control-label">Coverage (reviews/paper)</span>
                <input id="coverageInput" type="number" min="1" step="1" value="3">
              </div>
              <div class="control-group">
                <span class="control-label">Topic Top-k for Matching <span class="control-value" id="assignTopKValue">4</span></span>
                <input id="assignTopKInput" type="range" min="2" max="8" step="1" value="4">
              </div>
              <label class="toggle-row">
                <input id="strictCoiInput" type="checkbox" checked>
                Enforce COI constraints
              </label>
              <div class="btn-row" style="margin-top:8px">
                <button id="runAssignmentBtn" class="btn-primary" type="button">Run Assignment</button>
              </div>
            </div>

            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Expected JSON Schema</h3>
              <div class="tiny">
                Submission:<br>
                <code>{ submission_id, title, abstract, authors }</code><br><br>
                PC member:<br>
                <code>{ pc_id, role, name, publication_history:[{title, abstract}] }</code><br><br>
                COI matrix (supported):<br>
                <code>[{submission_id, pc_id, conflict:true}]</code> or nested object map.
              </div>
            </div>
          </div>
        </section>

        <section class="panel result-panel">
          <h2>Main Panel: Assignment Result</h2>
          <div id="assignmentSummary" class="summary"></div>

          <div class="tabs">
            <button id="paperViewBtn" class="small-tab is-active" type="button">Paper View</button>
            <button id="pcViewBtn" class="small-tab" type="button">PC Member View</button>
          </div>

          <div class="result-split">
            <div class="list-card">
              <h3 id="assignmentListTitle">Paper View List</h3>
              <div id="assignmentListTable" class="table-wrap"></div>
            </div>
            <div class="detail-card">
              <h3>Detail + Topic Distribution Explanation</h3>
              <div id="assignmentDetailPanel" class="tiny">Run assignment and click a paper or PC member to inspect details.</div>
            </div>
          </div>
        </section>
      </section>

      <section class="task-view" id="task-discovery">
        <section class="panel setup-panel">
          <h2>Setup Panel: PC Member Discovery</h2>
          <div class="grid-3">
            <div class="control-card">
              <div class="control-group">
                <span class="control-label">External Candidate Source</span>
                <select id="discoverySourceSelect">
                  <option value="OpenReview">OpenReview</option>
                  <option value="Semantic Scholar">Semantic Scholar</option>
                </select>
              </div>
              <div class="control-group">
                <span class="control-label">Required Role</span>
                <select id="discoveryRoleSelect">
                  <option value="Reviewer">Reviewer</option>
                  <option value="Area Chair">Area Chair</option>
                  <option value="Senior Area Chair">Senior Area Chair</option>
                </select>
              </div>
              <div class="control-group">
                <span class="control-label">Required PC Member Count</span>
                <input id="discoveryCountInput" type="number" min="1" step="1" value="8">
              </div>
              <div class="btn-row">
                <button id="runDiscoveryBtn" class="btn-primary" type="button">Start Search</button>
              </div>
            </div>

            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Behavior</h3>
              <div class="tiny">
                1. Compute current expertise-topic gap from uploaded submissions and current PC members.<br>
                2. Search candidates from selected source + role.<br>
                3. Auto-select top recommended candidates.<br>
                4. You can add/remove candidates in the result list; gap panel updates instantly.
              </div>
            </div>

            <div class="control-card">
              <h3 style="margin:0 0 8px;font-size:0.9rem">Inputs Used</h3>
              <div id="discoveryInputStatus" class="tiny"></div>
            </div>
          </div>
        </section>

        <section class="panel result-panel">
          <h2>Main Panel: Discovery Result</h2>
          <div class="result-split">
            <div class="gap-card">
              <h3>Expertise Gap (Before / After Selected Candidates)</h3>
              <div id="discoveryGapPanel" class="tiny">Run search to compute the gap.</div>
            </div>
            <div class="list-card">
              <h3>Candidate List (recommended selected by default)</h3>
              <div id="discoveryCandidateTable" class="table-wrap"></div>
            </div>
          </div>
        </section>
      </section>

      <section class="task-view" id="task-oral">
        <section class="panel setup-panel">
          <h2>Setup Panel: Oral Session Organization</h2>
          <div class="grid-3">
            <div class="control-card">
              <div class="btn-row">
                <button id="uploadOralPapersBtn" class="btn-secondary" type="button">Upload Oral Paper List</button>
                <input id="oralFileInput" type="file" accept=".json" style="display:none">
              </div>
              <div id="oralUploadStatus" class="tiny" style="margin-top:8px"></div>
            </div>

            <div class="control-card">
              <div class="control-group">
                <span class="control-label">Number of Parallel Sessions</span>
                <input id="oralParallelInput" type="number" min="1" step="1" value="2">
              </div>
              <div class="control-group">
                <span class="control-label">Maximum Papers per Session</span>
                <input id="oralMaxInput" type="number" min="1" step="1" value="4">
              </div>
              <div class="control-group">
                <span class="control-label">Total Number of Time Slots</span>
                <input id="oralSlotsInput" type="number" min="1" step="1" value="2">
              </div>
              <div class="btn-row">
                <button id="runOralBtn" class="btn-primary" type="button">Run Oral Organization</button>
              </div>
            </div>

            <div class="control-card">
              <div class="btn-row">
                <button id="exportOralBtn" class="btn-muted" type="button">Export Oral Result JSON</button>
              </div>
              <div class="tiny" style="margin-top:8px">After run, you can manually adjust assignments in the editor below. Export will use your adjusted final state.</div>
            </div>
          </div>
        </section>

        <section class="panel result-panel">
          <h2>Main Panel: Oral Schedule Result</h2>
          <div id="oralSummary" class="summary"></div>
          <div id="oralSchedulePanel" class="schedule-table"></div>
          <div class="editor-table" id="oralEditorPanel"></div>
        </section>
      </section>

      <section class="task-view" id="task-poster">
        <section class="panel setup-panel">
          <h2>Setup Panel: Poster Session Organization</h2>
          <div class="grid-3">
            <div class="control-card">
              <div class="btn-row">
                <button id="uploadPosterPapersBtn" class="btn-secondary" type="button">Upload Poster Paper List</button>
                <input id="posterFileInput" type="file" accept=".json" style="display:none">
              </div>
              <div id="posterUploadStatus" class="tiny" style="margin-top:8px"></div>
            </div>

            <div class="control-card">
              <div class="control-group">
                <span class="control-label">Venue Capacity Rows (N)</span>
                <input id="posterRowsInput" type="number" min="1" step="1" value="3">
              </div>
              <div class="control-group">
                <span class="control-label">Venue Capacity Columns (M)</span>
                <input id="posterColsInput" type="number" min="1" step="1" value="4">
              </div>
              <div class="control-group">
                <span class="control-label">Session Count</span>
                <input id="posterSessionCountInput" type="number" min="1" step="1" value="2">
              </div>
              <div class="btn-row">
                <button id="runPosterBtn" class="btn-primary" type="button">Run Poster Organization</button>
              </div>
            </div>

            <div class="control-card">
              <div class="btn-row">
                <button id="exportPosterBtn" class="btn-muted" type="button">Export Poster Result JSON</button>
              </div>
              <div class="tiny" style="margin-top:8px">Each table cell maps to a poster board. Manual adjustments in editor are reflected in export.</div>
            </div>
          </div>
        </section>

        <section class="panel result-panel">
          <h2>Main Panel: Poster Arrangement Result</h2>
          <div id="posterSummary" class="summary"></div>
          <div id="posterGridPanel"></div>
          <div class="editor-table" id="posterEditorPanel"></div>
        </section>
      </section>
    </main>
  </div>

  <script>
    const taxonomy = [
      { id: "root", parent: null, label: "Information Retrieval", w: 0, leaf: false },
      { id: "retrieval_core", parent: "root", label: "Retrieval Core", w: 0.34, leaf: false },
      { id: "gen_interactive", parent: "root", label: "Generative & Interactive IR", w: 0.31, leaf: false },
      { id: "recsys", parent: "root", label: "Recommendation", w: 0.29, leaf: false },
      { id: "methods", parent: "root", label: "Representation & Graph Methods", w: 0.28, leaf: false },
      { id: "evaluation", parent: "root", label: "Evaluation & Responsible IR", w: 0.30, leaf: false },
      { id: "reliability", parent: "root", label: "Reliability & Security", w: 0.30, leaf: false },
      { id: "neural_rank", parent: "retrieval_core", label: "Neural Ranking & Re-ranking", w: 0.18, leaf: true },
      { id: "index_ann", parent: "retrieval_core", label: "Indexing & ANN Systems", w: 0.17, leaf: true },
      { id: "gen_rag", parent: "gen_interactive", label: "Generative Retrieval & RAG", w: 0.18, leaf: true },
      { id: "convo_ir", parent: "gen_interactive", label: "Conversational & Interactive IR", w: 0.16, leaf: true },
      { id: "seq_rec", parent: "recsys", label: "Sequential Recommendation", w: 0.17, leaf: true },
      { id: "rec_objective", parent: "recsys", label: "Recommendation Objectives", w: 0.16, leaf: true },
      { id: "graph_method", parent: "methods", label: "Graph-based Modeling", w: 0.17, leaf: true },
      { id: "repr_embed", parent: "methods", label: "Embedding & Representation Learning", w: 0.16, leaf: true },
      { id: "user_eval", parent: "evaluation", label: "User, Evaluation & Explainability", w: 0.17, leaf: true },
      { id: "fair_bias", parent: "evaluation", label: "Fairness & Bias Mitigation", w: 0.16, leaf: true },
      { id: "robust_secure", parent: "reliability", label: "Robustness & Security", w: 0.17, leaf: true }
    ];

    const keywordLexicon = {
      neural_rank: [
        ["dense retrieval", 2.2], ["retrieval", 0.6], ["ranking", 1.6], ["re-ranking", 1.7], ["reranking", 1.7],
        ["cross-encoder", 1.9], ["bi-encoder", 1.8], ["learning-to-rank", 1.8], ["ranker", 1.2]
      ],
      index_ann: [
        ["index", 1.6], ["indexing", 1.6], ["ann", 1.8], ["approximate nearest neighbor", 2.0],
        ["nearest neighbor", 1.7], ["multi-vector", 1.7], ["vector search", 1.5], ["latency", 1.3],
        ["throughput", 1.2], ["scalable", 1.2], ["infrastructure", 1.3], ["benchmark", 1.2]
      ],
      gen_rag: [
        ["rag", 2.3], ["retrieval-augmented", 2.2], ["retrieval augmented", 2.2], ["large language model", 1.9],
        ["llm", 1.9], ["generative retrieval", 2.0], ["fact-check", 1.8], ["question-answer", 1.7],
        ["reasoning", 1.5], ["prompt", 1.4], ["alignment", 1.3]
      ],
      convo_ir: [
        ["conversational", 2.0], ["dialogue", 1.8], ["interactive search", 1.8], ["voice search", 1.7],
        ["clarification", 1.3], ["search behavior", 1.4], ["search behaviour", 1.4], ["user simulation", 1.3]
      ],
      seq_rec: [
        ["sequential recommendation", 2.2], ["session-based recommendation", 2.2], ["session recommendation", 2.0],
        ["next-item", 1.8], ["next item", 1.8], ["click sequence", 1.4], ["temporal user", 1.3]
      ],
      rec_objective: [
        ["recommendation objective", 1.8], ["multi-objective", 1.7], ["personalization", 1.4], ["diversified", 1.4],
        ["item-item", 1.4], ["collaborative filtering", 1.8], ["recommender systems", 1.2], ["exposure", 1.2]
      ],
      graph_method: [
        ["graph neural", 2.1], ["gnn", 2.1], ["graph-based", 1.9], ["hypergraph", 2.0],
        ["knowledge graph", 1.9], ["proximity graph", 1.8], ["message passing", 1.4]
      ],
      repr_embed: [
        ["embedding", 1.9], ["representation learning", 1.8], ["neural embedding", 2.0], ["hyperbolic", 1.8],
        ["distance approximation", 1.8], ["latent space", 1.4], ["metric learning", 1.4], ["diffusion", 1.2]
      ],
      user_eval: [
        ["evaluation", 1.7], ["benchmark", 1.5], ["calibration", 1.7], ["explainability", 1.8], ["shap", 1.8],
        ["user study", 1.6], ["measurement", 1.3], ["effectiveness", 1.3], ["search behaviours", 1.4]
      ],
      fair_bias: [
        ["fairness", 2.1], ["bias", 2.0], ["equity", 1.8], ["debias", 1.8], ["source bias", 2.0],
        ["polarization", 1.7], ["responsible ai", 1.4]
      ],
      robust_secure: [
        ["robust", 1.9], ["robustness", 1.9], ["adversarial", 1.9], ["drift", 1.6], ["noise", 1.3],
        ["security", 1.7], ["cyber threat", 1.8], ["reliability", 1.6], ["trust", 1.3], ["verification", 1.3]
      ]
    };

    const byId = Object.fromEntries(taxonomy.map((x) => [x.id, x]));
    const children = {};
    taxonomy.forEach((n) => {
      if (!n.parent) return;
      if (!children[n.parent]) children[n.parent] = [];
      children[n.parent].push(n.id);
    });
    const leafIds = taxonomy.filter((x) => x.leaf).map((x) => x.id);

    const descendants = {};
    function collectLeaves(nodeId) {
      if (descendants[nodeId]) return descendants[nodeId];
      const node = byId[nodeId];
      if (node.leaf) {
        descendants[nodeId] = [nodeId];
        return descendants[nodeId];
      }
      descendants[nodeId] = (children[nodeId] || []).flatMap((c) => collectLeaves(c));
      return descendants[nodeId];
    }
    taxonomy.forEach((n) => collectLeaves(n.id));

    function normalizeDist(dist) {
      const out = {};
      let sum = 0;
      leafIds.forEach((id) => {
        const v = Math.max(0, Number(dist[id] || 0));
        out[id] = v;
        sum += v;
      });
      if (sum <= 0) {
        const u = 1 / leafIds.length;
        leafIds.forEach((id) => { out[id] = u; });
        return out;
      }
      leafIds.forEach((id) => { out[id] /= sum; });
      return out;
    }

    function sparsify(dist, topK) {
      const sorted = Object.entries(dist).sort((a, b) => b[1] - a[1]);
      const keep = sorted.slice(0, topK);
      const out = {};
      leafIds.forEach((id) => { out[id] = 0; });
      let sum = 0;
      keep.forEach(([id, v]) => { out[id] = v; sum += v; });
      if (sum <= 0) return out;
      keep.forEach(([id]) => { out[id] /= sum; });
      return out;
    }

    function treeWasserstein(a, b) {
      let d = 0;
      taxonomy.forEach((node) => {
        if (!node.parent) return;
        const delta = descendants[node.id].reduce((acc, leaf) => acc + (a[leaf] || 0) - (b[leaf] || 0), 0);
        d += node.w * Math.abs(delta);
      });
      return d;
    }

    function similarity(a, b, topK = 4) {
      const dd = treeWasserstein(sparsify(a, topK), sparsify(b, topK));
      return Math.exp(-dd);
    }

    function textToDist(text) {
      const lower = String(text || "").toLowerCase();
      const raw = {};
      leafIds.forEach((leaf) => { raw[leaf] = 0.02; });
      Object.entries(keywordLexicon).forEach(([leaf, kws]) => {
        kws.forEach((entry) => {
          const kw = Array.isArray(entry) ? String(entry[0] || "").toLowerCase() : String(entry || "").toLowerCase();
          const w = Array.isArray(entry) ? Number(entry[1] || 1) : 1;
          if (!kw) return;
          let idx = 0;
          while (true) {
            const found = lower.indexOf(kw, idx);
            if (found === -1) break;
            raw[leaf] += w;
            idx = found + kw.length;
          }
        });
      });
      return normalizeDist(raw);
    }

    const hintRules = [
      { leaf: "neural_rank", re: /\b(dense retrieval|ranking|re-ranking|reranking|cross-encoder|bi-encoder|learning-to-rank)\b/g },
      { leaf: "index_ann", re: /\b(index|indexing|ann|approximate nearest neighbor|nearest neighbor|multi-vector|latency|throughput|infrastructure)\b/g },
      { leaf: "gen_rag", re: /\b(rag|retrieval-augmented|large language model|llm|generative|fact-check|reasoning|prompt|alignment)\b/g },
      { leaf: "convo_ir", re: /\b(conversational|dialogue|interactive search|voice search|clarification|search behavio[u]?r|user simulation)\b/g },
      { leaf: "seq_rec", re: /\b(sequential|session|next[- ]item|click sequence|temporal user)\b/g },
      { leaf: "rec_objective", re: /\b(recommendation objective|multi-objective|personalization|diversified|collaborative filtering|item-item|exposure)\b/g },
      { leaf: "graph_method", re: /\b(graph neural|gnn|graph-based|hypergraph|knowledge graph|proximity graph|message passing)\b/g },
      { leaf: "repr_embed", re: /\b(embedding|representation learning|neural embedding|hyperbolic|distance approximation|latent space|metric learning|diffusion)\b/g },
      { leaf: "user_eval", re: /\b(evaluation|benchmark|calibration|explainability|shap|user study|effectiveness|measurement)\b/g },
      { leaf: "fair_bias", re: /\b(fairness|bias|equity|debias|source bias|polarization|responsible ai)\b/g },
      { leaf: "robust_secure", re: /\b(robust|robustness|adversarial|drift|noise|security|cyber threat|reliability|trust|verification)\b/g }
    ];

    function inferTopicHintsFromText(text) {
      const lower = String(text || "").toLowerCase();
      const scores = {};
      leafIds.forEach((id) => { scores[id] = 0; });
      hintRules.forEach((rule) => {
        const matches = lower.match(rule.re);
        if (matches && matches.length) scores[rule.leaf] += matches.length;
      });
      const ranked = Object.entries(scores)
        .filter(([, v]) => v > 0)
        .sort((a, b) => b[1] - a[1])
        .map(([id]) => id);
      if (!ranked.length) return ["neural_rank"];
      return ranked.slice(0, 4);
    }

    function hintsToDist(hints) {
      const raw = {};
      leafIds.forEach((id) => { raw[id] = 0.01; });
      const uniq = [...new Set((Array.isArray(hints) ? hints : []).filter((h) => leafIds.includes(h)))];
      if (!uniq.length) return normalizeDist(raw);
      uniq.forEach((h, idx) => {
        raw[h] += Math.max(0.55, 1.2 - idx * 0.2);
      });
      return normalizeDist(raw);
    }

    function blendDists(baseDist, hintDist, textWeight = 0.72) {
      const raw = {};
      leafIds.forEach((id) => {
        raw[id] = textWeight * (baseDist[id] || 0) + (1 - textWeight) * (hintDist[id] || 0);
      });
      return normalizeDist(raw);
    }

    function avgDist(dists) {
      const raw = {};
      leafIds.forEach((l) => { raw[l] = 0; });
      if (!dists.length) return normalizeDist(raw);
      dists.forEach((d) => {
        leafIds.forEach((l) => { raw[l] += d[l] || 0; });
      });
      leafIds.forEach((l) => { raw[l] /= dists.length; });
      return normalizeDist(raw);
    }

    function formatPct(v) { return `${(v * 100).toFixed(1)}%`; }
    function formatNum(v, d = 3) { return Number(v).toFixed(d); }
    function keyPair(subId, pcId) { return `${subId}::${pcId}`; }
    function normalizeAuthors(rawAuthors) {
      if (Array.isArray(rawAuthors)) {
        return rawAuthors
          .map((a) => {
            if (typeof a === "string") return a.trim();
            if (a && typeof a === "object") return String(a.name || a.full_name || a.author_name || "").trim();
            return "";
          })
          .filter(Boolean);
      }
      if (typeof rawAuthors === "string") {
        return rawAuthors.split(",").map((x) => x.trim()).filter(Boolean);
      }
      if (rawAuthors && typeof rawAuthors === "object") {
        const v = String(rawAuthors.name || rawAuthors.full_name || rawAuthors.author_name || "").trim();
        return v ? [v] : [];
      }
      return [];
    }
    function authorsLabel(authors) {
      const arr = normalizeAuthors(authors);
      return arr.length ? arr.join(", ") : "N/A";
    }

    const topicHintAlias = {
      "retrieval core": "neural_rank",
      neural_rank: "neural_rank",
      dense_rank: "neural_rank",
      dense: "neural_rank",
      retrieval: "neural_rank",
      ranking: "neural_rank",
      reranking: "neural_rank",
      "re-ranking": "neural_rank",
      index_ann: "index_ann",
      infra: "index_ann",
      indexing: "index_ann",
      "indexing & ann systems": "index_ann",
      "retrieval infrastructure": "index_ann",
      ann: "index_ann",
      "vector search": "index_ann",
      "generative ir": "gen_rag",
      "generative retrieval": "gen_rag",
      rag: "gen_rag",
      "nlp for ir": "gen_rag",
      llm: "gen_rag",
      conversational: "convo_ir",
      convo_ux: "convo_ir",
      "interactive search": "convo_ir",
      "conversational & interactive ir": "convo_ir",
      seqrec: "seq_rec",
      seq_rec: "seq_rec",
      "sequential recommendation": "seq_rec",
      sequential: "seq_rec",
      session: "seq_rec",
      recsys: "rec_objective",
      "recommender modeling": "rec_objective",
      recsys_model: "rec_objective",
      "recommendation objectives": "rec_objective",
      collab: "rec_objective",
      "collaborative filtering": "rec_objective",
      collaborative: "rec_objective",
      gnn: "graph_method",
      graph: "graph_method",
      graph_rep: "graph_method",
      "graph-based modeling": "graph_method",
      "graph-based learning": "graph_method",
      "graph representation learning": "graph_method",
      deepwalk: "repr_embed",
      embedding: "repr_embed",
      representation: "repr_embed",
      "embedding & representation learning": "repr_embed",
      user_eval: "user_eval",
      "user, evaluation & explainability": "user_eval",
      evaluation: "user_eval",
      robust: "robust_secure",
      robustness: "robust_secure",
      reliability: "robust_secure",
      fair: "fair_bias",
      fairness: "fair_bias",
      fair_xai: "fair_bias",
      bias: "fair_bias",
      explainability: "user_eval"
    };

    function normalizeTopicHints(rawHints) {
      if (!rawHints) return [];
      const arr = Array.isArray(rawHints) ? rawHints : [rawHints];
      return [...new Set(arr
        .map((x) => String(x || "").trim().toLowerCase())
        .map((x) => topicHintAlias[x] || x)
        .filter((x) => leafIds.includes(x)))];
    }

    function topicHintsLabel(hints) {
      const arr = normalizeTopicHints(hints);
      return arr.length ? arr.map((id) => byId[id].label).join(", ") : "N/A";
    }

    const defaultSubmissionTopicHints = {
      "SIGIR25-001": ["seq_rec", "rec_objective", "robust_secure"],
      "SIGIR25-002": ["convo_ir", "seq_rec", "rec_objective"],
      "SIGIR25-003": ["gen_rag", "graph_method", "neural_rank"],
      "SIGIR25-004": ["neural_rank", "user_eval", "robust_secure"],
      "SIGIR25-005": ["gen_rag", "neural_rank", "robust_secure"],
      "SIGIR25-006": ["index_ann", "neural_rank", "graph_method"],
      "SIGIR25-007": ["robust_secure", "user_eval", "neural_rank"],
      "SIGIR25-008": ["user_eval", "gen_rag", "neural_rank"],
      "SIGIR25-009": ["neural_rank", "index_ann", "robust_secure"],
      "SIGIR25-010": ["gen_rag", "graph_method", "robust_secure"],
      "SIGIR25-011": ["gen_rag", "neural_rank", "user_eval"],
      "SIGIR25-012": ["seq_rec", "rec_objective", "convo_ir"],
      "SIGIR25-013": ["seq_rec", "rec_objective", "repr_embed"],
      "SIGIR25-014": ["repr_embed", "seq_rec", "rec_objective"],
      "SIGIR25-015": ["neural_rank", "graph_method", "repr_embed"],
      "SIGIR25-016": ["neural_rank", "gen_rag", "robust_secure"],
      "SIGIR25-017": ["graph_method", "rec_objective", "gen_rag"],
      "SIGIR25-018": ["repr_embed", "rec_objective", "gen_rag"],
      "SIGIR25-019": ["seq_rec", "rec_objective", "repr_embed"],
      "SIGIR25-020": ["seq_rec", "repr_embed", "robust_secure"],
      "SIGIR25-021": ["index_ann", "graph_method", "neural_rank"],
      "SIGIR25-022": ["gen_rag", "neural_rank", "convo_ir"],
      "SIGIR25-023": ["fair_bias", "gen_rag", "robust_secure"],
      "SIGIR25-024": ["seq_rec", "rec_objective", "robust_secure"],
      "SIGIR25-025": ["neural_rank", "repr_embed", "fair_bias"],
      "SIGIR25-026": ["neural_rank", "gen_rag", "repr_embed"],
      "SIGIR25-027": ["gen_rag", "neural_rank", "index_ann"],
      "SIGIR25-028": ["fair_bias", "seq_rec", "user_eval"],
      "SIGIR25-029": ["convo_ir", "user_eval", "robust_secure"],
      "SIGIR25-030": ["user_eval", "fair_bias", "neural_rank"]
    };

    function defaultSubmissions() {
      const rows = [
        {
          submission_id: "SIGIR25-001",
          title: "Techie: Tackling Video Prefetching at Edge Networks as POMDP Via an Intrinsically Motivated RL Agent",
          abstract: "Accepted at SIGIR 2025. The work studies retrieval-aware video prefetching with robust reinforcement learning and session-level recommendation signals.",
          authors: ["Nawras Alkassab", "Chin-Tser Huang", "Tania Lorido Botran"]
        },
        {
          submission_id: "SIGIR25-002",
          title: "Beyond Whole Dialogue Modeling: Contextual Disentanglement for Conversational Recommendation",
          abstract: "Accepted at SIGIR 2025. Conversational recommendation model with sequential intent separation and improved recommendation quality in multi-turn settings.",
          authors: ["Guojia An", "Jie Zou", "Jiwei Wei", "Chaoning Zhang", "Fuming Sun", "Yang Yang"]
        },
        {
          submission_id: "SIGIR25-003",
          title: "Question-Answer Extraction from Scientific Articles Using Knowledge Graphs and Large Language Models",
          abstract: "Accepted at SIGIR 2025. Scientific retrieval pipeline that combines knowledge graph reasoning with RAG-style evidence extraction.",
          authors: ["Hosein Azarbonyad", "Zi Long Zhu", "Georgios Cheirmpos", "Zubair Afzal", "Vikrant Yadav", "George Tsatsaronis"]
        },
        {
          submission_id: "SIGIR25-004",
          title: "Unconstrained Monotonic Calibration of Predictions in Deep Ranking Systems",
          abstract: "Accepted at SIGIR 2025. Ranking calibration for dense retrieval and reranking with strong robustness under score shift and noise.",
          authors: ["Yimeng Bai", "Shunyu Zhang", "Yang Zhang", "Hu Liu", "Wentian Bao", "Enyun Yu", "Fuli Feng", "Wenwu Ou"]
        },
        {
          submission_id: "SIGIR25-005",
          title: "Combining Evidence and Reasoning for Biomedical Fact-Checking",
          abstract: "Accepted at SIGIR 2025. Evidence retrieval and reasoning framework with retrieval-augmented generation for biomedical claim verification.",
          authors: ["Mariano Barone", "Antonio Romano", "Giuseppe Riccio", "Marco Postiglione", "Vincenzo Moscato"]
        },
        {
          submission_id: "SIGIR25-006",
          title: "IGP: Efficient Multi-Vector Retrieval via Proximity Graph Index",
          abstract: "Accepted at SIGIR 2025. Efficient dense retrieval and vector search using graph-based indexing for scalable multi-vector ranking.",
          authors: ["Zheng Bian", "Man Lung Yiu", "Bo Tang"]
        },
        {
          submission_id: "SIGIR25-007",
          title: "A Generalised and Adaptable Reinforcement Learning Stopping Method",
          abstract: "Accepted at SIGIR 2025. Adaptive stopping for retrieval and recommendation loops with improved robustness to uncertainty.",
          authors: ["Reem Bin-Hezam", "Mark Stevenson"]
        },
        {
          submission_id: "SIGIR25-008",
          title: "A New HOPE: Domain-agnostic Automatic Evaluation of Text Chunking",
          abstract: "Accepted at SIGIR 2025. Evaluates chunking for downstream dense retrieval and RAG pipelines across diverse domains.",
          authors: ["Henrik Bradland", "Morten Goodwin", "Per-Arne Andersen", "Alexander S. Nossum", "Aditya Gupta"]
        },
        {
          submission_id: "SIGIR25-009",
          title: "Efficient Re-ranking with Cross-encoders via Early Exit",
          abstract: "Accepted at SIGIR 2025. Cross-encoder reranking with early-exit inference for dense retrieval efficiency and robust latency control.",
          authors: ["Francesco Busolin", "Claudio Lucchese", "Franco Maria Nardini", "Salvatore Orlando", "Raffaele Perego", "Salvatore Trani", "Alberto Veneri"]
        },
        {
          submission_id: "SIGIR25-010",
          title: "A Knowledge Extraction Framework on Cyber Threat Reports with Enhanced Security Profiles",
          abstract: "Accepted at SIGIR 2025. Information extraction and retrieval with robust entity linking and graph-based reasoning in security reports.",
          authors: ["Yongxin Cai", "Jing Qiu", "Fan Zhang", "Qiang Li", "Lei Chen"]
        },
        {
          submission_id: "SIGIR25-011",
          title: "Exploring Training and Inference Scaling Laws in Generative Retrieval",
          abstract: "Accepted at SIGIR 2025. Analyzes scaling behavior of generative and dense retrieval systems, including retrieval-augmented generation.",
          authors: ["Hongru Cai", "Yongqi Li", "Ruifeng Yuan", "Wang Wenjie", "Zhen Zhang", "Wenjie Li", "Tat-Seng Chua"]
        },
        {
          submission_id: "SIGIR25-012",
          title: "Agentic Feedback Loop Modeling Improves Recommendation and User Simulation",
          abstract: "Accepted at SIGIR 2025. Feedback-loop aware sequential recommendation with robust user simulation for long-horizon interaction.",
          authors: ["Shihao Cai", "Jizhi Zhang", "Keqin Bao", "Chongming Gao", "Qifan Wang", "Fuli Feng", "Xiangnan He"]
        },
        {
          submission_id: "SIGIR25-013",
          title: "Unleashing the Potential of Diffusion Models Towards Diversified Sequential Recommendations",
          abstract: "Accepted at SIGIR 2025. Diffusion-based sequential recommendation for diversity with fairness-aware list quality metrics.",
          authors: ["Zhuo Cai", "Shoujin Wang", "Victor W. Chu", "Usman Naseem", "Yang Wang", "Fang Chen"]
        },
        {
          submission_id: "SIGIR25-014",
          title: "General Neural Embedding for Sequence Distance Approximation",
          abstract: "Accepted at SIGIR 2025. Neural embedding model for sequence matching used in recommendation and dense retrieval applications.",
          authors: ["Zhihao Chang", "Ding Wang", "Xiu Tang", "Kingsum Chow", "Jianwei Yin"]
        },
        {
          submission_id: "SIGIR25-015",
          title: "QDER: Query-Specific Document and Entity Representations for Multi-Vector Document Re-Ranking",
          abstract: "Accepted at SIGIR 2025. Query-specific dense retrieval and reranking with entity-aware multi-vector representations.",
          authors: ["Shubham Chatterjee", "Jeff Dalton"]
        },
        {
          submission_id: "SIGIR25-016",
          title: "DePro: Domain Ensemble using Decoupled Prompts for Universal Cross-Domain Retrieval",
          abstract: "Accepted at SIGIR 2025. Prompt-based dense retrieval transfer across domains with robust generalization and reduced bias.",
          authors: ["Kaixiang Chen", "Pengfei Fang", "Hui Xue"]
        },
        {
          submission_id: "SIGIR25-017",
          title: "CORONA: A Coarse-to-Fine Framework for Graph-based Recommendation with Large Language Models",
          abstract: "Accepted at SIGIR 2025. Graph recommendation with large language models, combining graph neural signals and retrieval augmentation.",
          authors: ["Junze Chen", "Xinjie Yang", "Cheng Yang", "Junfei Bao", "Zeyuan Guo", "Yawen Li", "Chuan Shi"]
        },
        {
          submission_id: "SIGIR25-018",
          title: "Large Language Models Enhanced Hyperbolic Space Recommender Systems",
          abstract: "Accepted at SIGIR 2025. Hyperbolic recommendation with LLM guidance for sequential user modeling and robust recommendation quality.",
          authors: ["Wentao Cheng", "Zhida Qin", "Zexue Wu", "Pengzhan Zhou", "Tianyu Huang"]
        },
        {
          submission_id: "SIGIR25-019",
          title: "Linear Item-Item Models with Neural Knowledge for Session-based Recommendation",
          abstract: "Accepted at SIGIR 2025. Session recommendation combining linear collaborative filtering and neural sequence knowledge.",
          authors: ["Minjin Choi", "Sunkyung Lee", "Seongmin Park", "Jongwuk Lee"]
        },
        {
          submission_id: "SIGIR25-020",
          title: "Dynamic Time-aware Continual User Representation Learning",
          abstract: "Accepted at SIGIR 2025. Continual representation learning for recommendation with robustness against temporal drift and noise.",
          authors: ["Seungyoon Choi", "Sein Kim", "Hong-Seok Kang", "Wonjoong Kim", "Chanyoung Park"]
        },
        {
          submission_id: "SIGIR25-021",
          title: "Locality-Sensitive Indexing for Graph-Based Approximate Nearest Neighbor Search",
          abstract: "Accepted at SIGIR 2025. Graph-based ANN indexing for dense retrieval and large-scale vector search.",
          authors: ["Jun Woo Chung", "Huawei Lin", "Weijie Zhao"]
        },
        {
          submission_id: "SIGIR25-022",
          title: "CIRAG: Retrieval-Augmented Language Model with Collective Intelligence",
          abstract: "Accepted at SIGIR 2025. Retrieval-augmented generation with collective intelligence for robust answer synthesis.",
          authors: ["Chenxu Cui", "Haihui Fan", "Jinchao Zhang", "Lin Shen", "Bo Li", "Weiping Wang"]
        },
        {
          submission_id: "SIGIR25-023",
          title: "Mitigating Source Bias with LLM Alignment",
          abstract: "Accepted at SIGIR 2025. Addresses source bias and fairness in LLM-based retrieval and ranking with alignment objectives.",
          authors: ["Sunhao Dai", "Yuqi Zhou", "Liang Pang", "Zhuoyang Li", "Zhaocheng Du", "Gang Wang", "Jun Xu"]
        },
        {
          submission_id: "SIGIR25-024",
          title: "Data Augmentation as Free Lunch: Exploring the Test-Time Augmentation for Sequential Recommendation",
          abstract: "Accepted at SIGIR 2025. Test-time augmentation for sequential recommendation with improved robustness and diversity.",
          authors: ["Yizhou Dang", "Yuting Liu", "Enneng Yang", "Minhan Huang", "Guibing Guo", "Jianzhe Zhao", "Xingwei Wang"]
        },
        {
          submission_id: "SIGIR25-025",
          title: "CSMF: Cascaded Selective Mask Fine-Tuning for Multi-Objective Embedding-Based Retrieval",
          abstract: "Accepted at SIGIR 2025. Multi-objective dense retrieval tuning balancing relevance, fairness, and robust performance.",
          authors: ["Hao Deng", "Haibo Xing", "Kanefumi Matsuyama", "Moyu Zhang", "Jinxin Hu", "Hong Wen", "Yu Zhang", "Xiaoyi Zeng", "Jing Zhang"]
        },
        {
          submission_id: "SIGIR25-026",
          title: "Open-World Fine-Grained Fashion Retrieval with LLM-based Commonsense Knowledge Infusion",
          abstract: "Accepted at SIGIR 2025. Open-world retrieval with LLM knowledge infusion and dense retrieval for fine-grained matching.",
          authors: ["Jianfeng Dong", "Junwei Zhu", "Daizong Liu", "Xiaoye Qu", "Cuizhu Bao", "Zhike Han", "Jixiang Zhu", "Xun Wang"]
        },
        {
          submission_id: "SIGIR25-027",
          title: "Reasoning and Retrieval for Complex Tables via Reinforced Relational Data Transformation",
          abstract: "Accepted at SIGIR 2025. Relational reasoning plus dense retrieval for complex table question answering in RAG settings.",
          authors: ["Haoyu Dong", "Yue Hu", "Yanan Cao"]
        },
        {
          submission_id: "SIGIR25-028",
          title: "Understanding the Effect of Opinion Polarization in Short Video Browsing",
          abstract: "Accepted at SIGIR 2025. User behavior study for recommendation feeds with fairness and robustness implications.",
          authors: ["Bangde Du", "Ziyi Ye", "Zhijing Wu", "Monika Jankowska", "Qingyao Ai", "Yiqun Liu"]
        },
        {
          submission_id: "SIGIR25-029",
          title: "Query Smarter, Trust Better? Exploring Search Behaviours for Verifying News Accuracy",
          abstract: "Accepted at SIGIR 2025. Search behavior analysis for trust and robustness, including retrieval support for news verification.",
          authors: ["David Elsweiler", "Samy Ateia", "Markus Bink", "Gregor Donabauer", "Marcos Fernandez Pichel", "Alexander Frummet", "Udo Kruschwitz", "David E. Losada", "Bernd Ludwig", "Selina Meyer", "Noel Pascual Presa"]
        },
        {
          submission_id: "SIGIR25-030",
          title: "Explaining Ranking Decisions through a Listwise SHAP Explainer",
          abstract: "Accepted at SIGIR 2025. Ranking explanation method for dense retrieval systems with fairness and transparency diagnostics.",
          authors: ["Maria Heuss", "Maarten de Rijke", "Avishek Anand"]
        }
      ];
      return rows.map((row) => ({
        ...row,
        topic_hints: normalizeTopicHints(defaultSubmissionTopicHints[row.submission_id] || inferTopicHintsFromText(`${row.title || ""} ${row.abstract || ""}`))
      }));
    }

    function defaultPcMembers() {
      return [
        {
          pc_id: "P001",
          role: "Senior Area Chair",
          name: "Omar Alonso",
          publication_history: [
            { title: "Expertise Profile: Web Search and Ranking Evaluation", abstract: "Search quality evaluation, retrieval effectiveness, and robust ranking workflows." },
            { title: "Expertise Profile: Applied IR in Industry", abstract: "Operational information retrieval systems and recommendation deployment." }
          ]
        },
        {
          pc_id: "P002",
          role: "Senior Area Chair",
          name: "Andrew Trotman",
          publication_history: [
            { title: "Expertise Profile: Efficient Retrieval and Query Processing", abstract: "Efficient ranking algorithms, dense retrieval infrastructure, and robust latency optimization." },
            { title: "Expertise Profile: Evaluation Methodology", abstract: "IR benchmarking, reproducibility, and effectiveness measurement." }
          ]
        },
        {
          pc_id: "P003",
          role: "Area Chair",
          name: "Suzan Verberne",
          publication_history: [
            { title: "Expertise Profile: Conversational Search", abstract: "Conversational information retrieval and interactive search behavior modeling." },
            { title: "Expertise Profile: Trustworthy Retrieval", abstract: "User-centered trust and robustness considerations in search interfaces." }
          ]
        },
        {
          pc_id: "P004",
          role: "Area Chair",
          name: "Ebrahim Bagheri",
          publication_history: [
            { title: "Expertise Profile: Neural IR and Query Understanding", abstract: "Dense retrieval, reranking, and query intent modeling with neural methods." },
            { title: "Expertise Profile: Personalized Search", abstract: "User modeling and recommendation for personalized information access." }
          ]
        },
        {
          pc_id: "P005",
          role: "Reviewer",
          name: "Faegheh Hasibi",
          publication_history: [
            { title: "Expertise Profile: Entity-Oriented Retrieval", abstract: "Entity retrieval, knowledge-rich ranking, and graph-based search." },
            { title: "Expertise Profile: Generative IR", abstract: "RAG pipelines and dense retrieval for factual response generation." }
          ]
        },
        {
          pc_id: "P006",
          role: "Reviewer",
          name: "Joel Mackenzie",
          publication_history: [
            { title: "Expertise Profile: Efficient Top-k Retrieval", abstract: "Scalable search systems, learned indexes, and robust efficiency tradeoffs." },
            { title: "Expertise Profile: System Reproducibility", abstract: "Benchmarking and repeatable evaluation for IR systems." }
          ]
        },
        {
          pc_id: "P007",
          role: "Senior Area Chair",
          name: "Ian Soboroff",
          publication_history: [
            { title: "Expertise Profile: TREC Evaluation and Test Collections", abstract: "IR test collection design and reliable ranking evaluation." },
            { title: "Expertise Profile: Risk-Sensitive Retrieval", abstract: "Robust search quality analysis under domain and data shift." }
          ]
        },
        {
          pc_id: "P008",
          role: "Area Chair",
          name: "Johanne Trippas",
          publication_history: [
            { title: "Expertise Profile: Conversational and Voice Search", abstract: "Conversational retrieval and user interaction in spoken settings." },
            { title: "Expertise Profile: User-Centric IR", abstract: "Search behavior, satisfaction, and fairness-aware evaluation." }
          ]
        },
        {
          pc_id: "P009",
          role: "Senior Area Chair",
          name: "Kenneth Church",
          publication_history: [
            { title: "Expertise Profile: Language and Information Access", abstract: "Language modeling for retrieval, corpus analysis, and IR applications." },
            { title: "Expertise Profile: Responsible AI for Search", abstract: "Bias, fairness, and robust use of large language models in retrieval." }
          ]
        },
        {
          pc_id: "P010",
          role: "Senior Area Chair",
          name: "Diane Kelly",
          publication_history: [
            { title: "Expertise Profile: Interactive IR and Search UX", abstract: "User behavior modeling and evaluation in interactive retrieval." },
            { title: "Expertise Profile: Human-Centered Relevance", abstract: "Relevance feedback, user studies, and trustworthy ranking design." }
          ]
        },
        {
          pc_id: "P011",
          role: "Area Chair",
          name: "Eugene Agichtein",
          publication_history: [
            { title: "Expertise Profile: Neural Ranking and QA Retrieval", abstract: "Question answering, dense retrieval, and robust reranking." },
            { title: "Expertise Profile: Social and Community Search", abstract: "Search over social signals and behavioral data." }
          ]
        },
        {
          pc_id: "P012",
          role: "Reviewer",
          name: "Rodrygo Santos",
          publication_history: [
            { title: "Expertise Profile: Learning-to-Rank", abstract: "Ranking optimization and evaluation for web and enterprise search." },
            { title: "Expertise Profile: Retrieval Robustness", abstract: "Generalization analysis and robust ranking strategies." }
          ]
        },
        {
          pc_id: "P013",
          role: "Reviewer",
          name: "Zhaochun Ren",
          publication_history: [
            { title: "Expertise Profile: Conversational and Generative Retrieval", abstract: "Conversational search, dense retrieval, and RAG for QA." },
            { title: "Expertise Profile: Scientific and Knowledge Retrieval", abstract: "Knowledge-grounded retrieval and graph-enhanced ranking." }
          ]
        },
        {
          pc_id: "P014",
          role: "Area Chair",
          name: "Michael Bendersky",
          publication_history: [
            { title: "Expertise Profile: Query Understanding and Ranking", abstract: "Large-scale ranking systems, retrieval models, and query interpretation." },
            { title: "Expertise Profile: Applied Dense Retrieval", abstract: "Neural retrieval and production ranking pipelines." }
          ]
        },
        {
          pc_id: "P015",
          role: "Reviewer",
          name: "Behrooz Mansouri",
          publication_history: [
            { title: "Expertise Profile: Neural IR", abstract: "Dense retrieval and reranking with modern language models." },
            { title: "Expertise Profile: Retrieval Benchmarking", abstract: "Comparative evaluation and reproducible IR experimentation." }
          ]
        },
        {
          pc_id: "P016",
          role: "Area Chair",
          name: "Don Metzler",
          publication_history: [
            { title: "Expertise Profile: Search Foundation Models", abstract: "Large language models for retrieval, ranking, and query reformulation." },
            { title: "Expertise Profile: Scalable IR", abstract: "Robust retrieval architectures for web-scale search." }
          ]
        },
        {
          pc_id: "P017",
          role: "Area Chair",
          name: "Alistair Moffat",
          publication_history: [
            { title: "Expertise Profile: Efficient Search Structures", abstract: "Compressed indexes and high-performance retrieval algorithms." },
            { title: "Expertise Profile: Ranking Effectiveness", abstract: "Evaluation methods and robust ranking quality analysis." }
          ]
        },
        {
          pc_id: "P018",
          role: "Reviewer",
          name: "Charlie Clarke",
          publication_history: [
            { title: "Expertise Profile: Retrieval Evaluation and Fairness", abstract: "Search evaluation, effectiveness, and fairness in ranking." },
            { title: "Expertise Profile: Text Retrieval", abstract: "Ad hoc retrieval with robust ranking and user-oriented quality metrics." }
          ]
        },
        {
          pc_id: "P019",
          role: "Reviewer",
          name: "Doug Oard",
          publication_history: [
            { title: "Expertise Profile: Cross-Language Information Retrieval", abstract: "Multilingual retrieval and user-assisted search." },
            { title: "Expertise Profile: Human-in-the-Loop Retrieval", abstract: "Interactive relevance feedback and robust search workflows." }
          ]
        },
        {
          pc_id: "P020",
          role: "Reviewer",
          name: "Chirag Shah",
          publication_history: [
            { title: "Expertise Profile: Generative AI for IR", abstract: "RAG, conversational search, and task-oriented information access." },
            { title: "Expertise Profile: Responsible Search", abstract: "Fairness and transparency in modern retrieval systems." }
          ]
        },
        {
          pc_id: "P021",
          role: "Reviewer",
          name: "Ryen White",
          publication_history: [
            { title: "Expertise Profile: Search Behavior and Health IR", abstract: "User behavior modeling and robust search support in sensitive domains." },
            { title: "Expertise Profile: Conversational Search", abstract: "Interactive retrieval and query reformulation strategies." }
          ]
        },
        {
          pc_id: "P022",
          role: "Senior Area Chair",
          name: "Maarten de Rijke",
          publication_history: [
            { title: "Expertise Profile: Neural Ranking and Recommender Systems", abstract: "Dense retrieval, learning-to-rank, and recommendation optimization." },
            { title: "Expertise Profile: Explainable and Fair Retrieval", abstract: "Transparent ranking, fairness, and trustworthy IR." }
          ]
        },
        {
          pc_id: "P023",
          role: "Reviewer",
          name: "Hamed Zamani",
          publication_history: [
            { title: "Expertise Profile: Language Models for Retrieval", abstract: "Neural retrieval, query-document matching, and robust transfer." },
            { title: "Expertise Profile: Efficient Dense Retrieval", abstract: "Indexing, reranking, and scalable retrieval architectures." }
          ]
        },
        {
          pc_id: "P024",
          role: "Reviewer",
          name: "Jimmy Lin",
          publication_history: [
            { title: "Expertise Profile: Dense Retrieval Tooling", abstract: "Reproducible dense retrieval pipelines and benchmark engineering." },
            { title: "Expertise Profile: Retrieval Infrastructure", abstract: "Scalable search systems and evaluation frameworks." }
          ]
        }
      ];
    }

    function defaultCoiSet() {
      const set = new Set();
      set.add(keyPair("SIGIR25-002", "P003"));
      set.add(keyPair("SIGIR25-003", "P013"));
      set.add(keyPair("SIGIR25-004", "P022"));
      set.add(keyPair("SIGIR25-005", "P020"));
      set.add(keyPair("SIGIR25-006", "P017"));
      set.add(keyPair("SIGIR25-008", "P021"));
      set.add(keyPair("SIGIR25-009", "P016"));
      set.add(keyPair("SIGIR25-011", "P023"));
      set.add(keyPair("SIGIR25-012", "P022"));
      set.add(keyPair("SIGIR25-013", "P004"));
      set.add(keyPair("SIGIR25-015", "P014"));
      set.add(keyPair("SIGIR25-016", "P005"));
      set.add(keyPair("SIGIR25-017", "P013"));
      set.add(keyPair("SIGIR25-018", "P024"));
      set.add(keyPair("SIGIR25-020", "P011"));
      set.add(keyPair("SIGIR25-022", "P001"));
      set.add(keyPair("SIGIR25-023", "P009"));
      set.add(keyPair("SIGIR25-024", "P010"));
      set.add(keyPair("SIGIR25-029", "P018"));
      set.add(keyPair("SIGIR25-030", "P022"));
      return set;
    }

    function defaultExternalCandidates() {
      return [
        { pc_id: "X101", source: "OpenReview", role: "Reviewer", name: "Chengxiang Zhai", publication_history: [{ title: "Expertise Profile: Foundations of Information Retrieval", abstract: "Query modeling, retrieval theory, and language-model-based ranking." }] },
        { pc_id: "X102", source: "OpenReview", role: "Senior Area Chair", name: "W. Bruce Croft", publication_history: [{ title: "Expertise Profile: Search and Retrieval Models", abstract: "Core retrieval models, web search, and ranking architectures." }] },
        { pc_id: "X103", source: "OpenReview", role: "Area Chair", name: "Hang Li", publication_history: [{ title: "Expertise Profile: Neural Ranking and NLP", abstract: "Ranking, language understanding, and large-scale retrieval applications." }] },
        { pc_id: "X104", source: "OpenReview", role: "Reviewer", name: "Krisztian Balog", publication_history: [{ title: "Expertise Profile: Entity Retrieval and Recommender Systems", abstract: "Entity-centric retrieval, recommendation, and evaluation." }] },
        { pc_id: "X105", source: "OpenReview", role: "Reviewer", name: "Leif Azzopardi", publication_history: [{ title: "Expertise Profile: Interactive IR and Search Economics", abstract: "Interactive retrieval and user-centered search optimization." }] },
        { pc_id: "X106", source: "OpenReview", role: "Reviewer", name: "Jiaul Paik", publication_history: [{ title: "Expertise Profile: Retrieval Effectiveness", abstract: "Ad hoc retrieval and robust ranking evaluation." }] },
        { pc_id: "X107", source: "OpenReview", role: "Area Chair", name: "Emine Yilmaz", publication_history: [{ title: "Expertise Profile: User Modeling and Ranking", abstract: "Search behavior modeling and personalized ranking." }] },
        { pc_id: "X108", source: "OpenReview", role: "Reviewer", name: "Yiqun Liu", publication_history: [{ title: "Expertise Profile: Search Interaction and Fairness", abstract: "Interactive retrieval and trustworthy ranking analysis." }] },
        { pc_id: "X109", source: "OpenReview", role: "Reviewer", name: "Min Zhang", publication_history: [{ title: "Expertise Profile: Recommendation and Search", abstract: "Recommender systems, sequential recommendation, and IR evaluation." }] },
        { pc_id: "X110", source: "OpenReview", role: "Reviewer", name: "Jiyin He", publication_history: [{ title: "Expertise Profile: Responsible and Explainable IR", abstract: "Fairness and explainability in retrieval and ranking." }] },
        { pc_id: "X111", source: "OpenReview", role: "Area Chair", name: "Noriko Kando", publication_history: [{ title: "Expertise Profile: Evaluation Campaigns", abstract: "IR benchmarks, reproducibility, and multilingual retrieval." }] },
        { pc_id: "X112", source: "OpenReview", role: "Reviewer", name: "Fabrizio Silvestri", publication_history: [{ title: "Expertise Profile: Web Search Infrastructure", abstract: "Scalable ranking, search logs, and production retrieval systems." }] },
        { pc_id: "X113", source: "OpenReview", role: "Reviewer", name: "Roi Blanco", publication_history: [{ title: "Expertise Profile: Efficient Ranking", abstract: "Retrieval efficiency, neural ranking, and query optimization." }] },
        { pc_id: "X114", source: "OpenReview", role: "Reviewer", name: "Jimmy Lin", publication_history: [{ title: "Expertise Profile: Dense Retrieval Reproducibility", abstract: "Dense retrieval baselines, benchmark tooling, and robust experimentation." }] },
        { pc_id: "X115", source: "OpenReview", role: "Reviewer", name: "Hamed Zamani", publication_history: [{ title: "Expertise Profile: Neural Retrieval", abstract: "Dense retrieval, reranking, and query-document representation learning." }] },
        { pc_id: "X116", source: "OpenReview", role: "Reviewer", name: "Zhaochun Ren", publication_history: [{ title: "Expertise Profile: Conversational and Generative Search", abstract: "Conversational retrieval and RAG-based question answering." }] },
        { pc_id: "X117", source: "Semantic Scholar", role: "Reviewer", name: "Jaime Teevan", publication_history: [{ title: "Expertise Profile: Personal Search and Productivity", abstract: "Personalized information access and user-centric retrieval design." }] },
        { pc_id: "X118", source: "Semantic Scholar", role: "Reviewer", name: "Eugene Agichtein", publication_history: [{ title: "Expertise Profile: QA Retrieval and Ranking", abstract: "Question answering, ranking quality, and robust retrieval methods." }] },
        { pc_id: "X119", source: "Semantic Scholar", role: "Area Chair", name: "Michael Bendersky", publication_history: [{ title: "Expertise Profile: Industrial Search Ranking", abstract: "Large-scale ranking, query understanding, and retrieval optimization." }] },
        { pc_id: "X120", source: "Semantic Scholar", role: "Reviewer", name: "Rodrygo Santos", publication_history: [{ title: "Expertise Profile: Learning-to-Rank", abstract: "Ranking algorithms and robust evaluation in IR tasks." }] },
        { pc_id: "X121", source: "Semantic Scholar", role: "Reviewer", name: "Omar Alonso", publication_history: [{ title: "Expertise Profile: Search Evaluation in Practice", abstract: "Evaluation workflows, quality diagnostics, and ranking analytics." }] },
        { pc_id: "X122", source: "Semantic Scholar", role: "Reviewer", name: "Andrew Trotman", publication_history: [{ title: "Expertise Profile: Retrieval Algorithms and Efficiency", abstract: "Top-k retrieval, indexing, and scalable ranking systems." }] },
        { pc_id: "X123", source: "Semantic Scholar", role: "Reviewer", name: "Suzan Verberne", publication_history: [{ title: "Expertise Profile: Conversational Search", abstract: "Interactive retrieval, conversational agents, and user studies." }] },
        { pc_id: "X124", source: "Semantic Scholar", role: "Reviewer", name: "Faegheh Hasibi", publication_history: [{ title: "Expertise Profile: Entity and Graph Retrieval", abstract: "Entity-centric search, graph-based retrieval, and neural reranking." }] },
        { pc_id: "X125", source: "Semantic Scholar", role: "Reviewer", name: "Joel Mackenzie", publication_history: [{ title: "Expertise Profile: Search System Engineering", abstract: "Efficient query processing and retrieval benchmarking." }] },
        { pc_id: "X126", source: "Semantic Scholar", role: "Senior Area Chair", name: "Ian Soboroff", publication_history: [{ title: "Expertise Profile: IR Evaluation and Test Collections", abstract: "Evaluation metrics, pooling, and robust testbed design." }] },
        { pc_id: "X127", source: "Semantic Scholar", role: "Area Chair", name: "Johanne Trippas", publication_history: [{ title: "Expertise Profile: Voice and Conversational IR", abstract: "Conversational search experiences and interaction modeling." }] },
        { pc_id: "X128", source: "Semantic Scholar", role: "Senior Area Chair", name: "Kenneth Church", publication_history: [{ title: "Expertise Profile: NLP for Retrieval", abstract: "Language modeling, text processing, and ranking improvements." }] },
        { pc_id: "X129", source: "Semantic Scholar", role: "Senior Area Chair", name: "Diane Kelly", publication_history: [{ title: "Expertise Profile: Human-Centered IR", abstract: "Interactive evaluation, relevance judgment, and trustworthy search." }] },
        { pc_id: "X130", source: "Semantic Scholar", role: "Area Chair", name: "Don Metzler", publication_history: [{ title: "Expertise Profile: Foundation Models for Search", abstract: "Large language models and neural retrieval at web scale." }] },
        { pc_id: "X131", source: "Semantic Scholar", role: "Area Chair", name: "Maarten de Rijke", publication_history: [{ title: "Expertise Profile: Neural Ranking and Recommendation", abstract: "Ranking optimization, recommendation, and explainable retrieval." }] },
        { pc_id: "X132", source: "Semantic Scholar", role: "Reviewer", name: "Alistair Moffat", publication_history: [{ title: "Expertise Profile: Retrieval Efficiency", abstract: "Index compression, efficient top-k search, and evaluation." }] },
        { pc_id: "X133", source: "Semantic Scholar", role: "Reviewer", name: "Charlie Clarke", publication_history: [{ title: "Expertise Profile: Retrieval Quality and Fairness", abstract: "Search quality metrics, fairness, and robust ranking." }] },
        { pc_id: "X134", source: "Semantic Scholar", role: "Reviewer", name: "Doug Oard", publication_history: [{ title: "Expertise Profile: Multilingual and Interactive Retrieval", abstract: "Cross-language retrieval and human-in-the-loop ranking." }] },
        { pc_id: "X135", source: "Semantic Scholar", role: "Reviewer", name: "Chirag Shah", publication_history: [{ title: "Expertise Profile: Generative AI for Search", abstract: "RAG systems, conversational IR, and responsible AI in search." }] },
        { pc_id: "X136", source: "Semantic Scholar", role: "Reviewer", name: "Ryen White", publication_history: [{ title: "Expertise Profile: Search Behavior Analytics", abstract: "User behavior modeling and retrieval support for information tasks." }] }
      ];
    }

    function defaultOralPapers() {
      return [
        { submission_id: "O1", title: "Graph-based Session Recommendation", abstract: "GNN and sequential recommendation.", authors: ["A. Kim", "J. Patel"] },
        { submission_id: "O2", title: "Fair Collaborative Filtering", abstract: "Fairness and equity in collaborative filtering.", authors: ["M. Rossi", "T. Nguyen"] },
        { submission_id: "O3", title: "Robust Dense Retrieval", abstract: "Dense retrievers under adversarial drift.", authors: ["R. Singh", "Y. Zhang"] },
        { submission_id: "O4", title: "RAG for Conference Assistance", abstract: "Retrieval augmented generation for reviewer support.", authors: ["L. Chen", "K. Ahmed"] },
        { submission_id: "O5", title: "DeepWalk Distillation", abstract: "Random walk embeddings for efficient ranking.", authors: ["P. Lopez", "D. Park"] },
        { submission_id: "O6", title: "Hypergraph Recommendation", abstract: "Hypergraph neural approaches for recommender systems.", authors: ["S. Brown", "N. Li"] }
      ];
    }

    function defaultPosterPapers() {
      return [
        { submission_id: "T1", title: "Bias Auditing in Reviewer Search", abstract: "Fairness auditing for reviewer retrieval.", authors: ["C. Wang", "E. Davis"] },
        { submission_id: "T2", title: "Dense Retriever Compression", abstract: "Vector retriever optimization and compression.", authors: ["R. Singh", "Y. Zhang"] },
        { submission_id: "T3", title: "Sequential Recommendation with Contrastive Learning", abstract: "Session recommendation with contrastive objectives.", authors: ["A. Kim", "J. Patel"] },
        { submission_id: "T4", title: "Poison-resistant Ranking Models", abstract: "Robust ranking under poisoning attacks.", authors: ["H. Lee", "F. Martin"] },
        { submission_id: "T5", title: "GNN Explainability in Recsys", abstract: "Explain graph neural recommendation models.", authors: ["S. Brown", "N. Li"] },
        { submission_id: "T6", title: "RAG-driven Scholar Exploration", abstract: "Retrieval-augmented exploration of scientific corpora.", authors: ["L. Chen", "K. Ahmed"] },
        { submission_id: "T7", title: "DeepWalk Variants for Item Graphs", abstract: "Random walk graph representations for items.", authors: ["P. Lopez", "D. Park"] },
        { submission_id: "T8", title: "Fair Exposure in Poster Recommendation", abstract: "Fairness for visibility and exposure.", authors: ["M. Rossi", "T. Nguyen"] }
      ];
    }

    const state = {
      activeTask: "assignment",
      assignment: {
        submissions: defaultSubmissions(),
        pcMembers: defaultPcMembers(),
        coi: defaultCoiSet(),
        workload: 4,
        coverage: 3,
        topK: 4,
        strictCoi: true,
        result: null,
        viewMode: "paper",
        selected: null
      },
      discovery: {
        source: "OpenReview",
        role: "Reviewer",
        requiredCount: 8,
        externalCandidates: defaultExternalCandidates(),
        recommendedIds: [],
        selectedIds: new Set(),
        result: null
      },
      oral: {
        papers: defaultOralPapers(),
        parallelSessions: 2,
        maxPerSession: 4,
        timeSlots: 2,
        result: null
      },
      poster: {
        papers: defaultPosterPapers(),
        rows: 3,
        cols: 4,
        sessionCount: 2,
        result: null
      }
    };

    function submissionDist(sub) {
      const text = `${sub.title || ""} ${sub.abstract || ""}`;
      const base = textToDist(text);
      const hints = Array.isArray(sub.topic_hints) && sub.topic_hints.length
        ? normalizeTopicHints(sub.topic_hints)
        : inferTopicHintsFromText(text);
      const textWeight = hints.length ? 0.3 : 0.7;
      return blendDists(base, hintsToDist(hints), textWeight);
    }

    function pcDist(pc) {
      const pubs = Array.isArray(pc.publication_history) ? pc.publication_history : [];
      const fallbackText = `${pc.name || ""} ${pc.title || ""} ${pc.role || ""}`;
      const sourceText = pubs.length
        ? pubs.map((p) => `${p.title || ""} ${p.abstract || ""}`).join(" ")
        : fallbackText;
      const base = pubs.length
        ? avgDist(pubs.map((p) => textToDist(`${p.title || ""} ${p.abstract || ""}`)))
        : textToDist(sourceText);
      const hints = Array.isArray(pc.topic_hints) && pc.topic_hints.length
        ? pc.topic_hints
        : inferTopicHintsFromText(sourceText);
      return blendDists(base, hintsToDist(hints), 0.74);
    }

    function topTopicEntries(dist, limit = 4) {
      return leafIds
        .map((id) => ({ id, v: dist[id] || 0 }))
        .sort((a, b) => b.v - a.v)
        .slice(0, limit);
    }

    function barsHtml(dist, cls = "") {
      return `
        <div class="bars">
          ${topTopicEntries(dist, 6).map((x) => `
            <div class="bar-row">
              <div>${byId[x.id].label}</div>
              <div class="bar-track"><div class="bar-fill ${cls}" style="width:${(x.v * 100).toFixed(2)}%"></div></div>
              <div class="mono">${formatPct(x.v)}</div>
            </div>
          `).join("")}
        </div>
      `;
    }

    function parseJsonFile(file, onSuccess) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const json = JSON.parse(String(e.target.result || ""));
          onSuccess(json);
        } catch (_) {
          alert("Invalid JSON file.");
        }
      };
      reader.onerror = () => alert("Failed to read file.");
      reader.readAsText(file);
    }

    function normalizeSubmissionList(payload) {
      const rows = Array.isArray(payload)
        ? payload
        : Array.isArray(payload.submissions)
          ? payload.submissions
          : [];
      return rows
        .map((x) => ({
          submission_id: x.submission_id || x.id || x.paper_id,
          title: x.title || "Untitled",
          abstract: x.abstract || "",
          authors: normalizeAuthors(x.authors || x.author || x.author_names || x.authorNames),
          topic_hints: normalizeTopicHints(x.topic_hints || x.topics || x.topic_tags || x.topicTags)
        }))
        .filter((x) => x.submission_id);
    }

    function normalizePcList(payload) {
      const rows = Array.isArray(payload)
        ? payload
        : Array.isArray(payload.pc_members)
          ? payload.pc_members
          : Array.isArray(payload.pcMembers)
            ? payload.pcMembers
            : [];

      return rows
        .map((x) => ({
          pc_id: x.pc_id || x.id,
          role: x.role || "Reviewer",
          name: x.name || x.full_name || x.display_name || x.pc_name || x.pc_id || x.id || "Unknown",
          publication_history: Array.isArray(x.publication_history) ? x.publication_history.map((p) => ({ title: p.title || "", abstract: p.abstract || "" })) : []
        }))
        .filter((x) => x.pc_id);
    }

    function normalizeCoi(payload) {
      const set = new Set();

      function push(subId, pcId, flag = true) {
        if (!subId || !pcId) return;
        if (flag) set.add(keyPair(String(subId), String(pcId)));
      }

      if (Array.isArray(payload)) {
        payload.forEach((row) => {
          if (Array.isArray(row) && row.length >= 2) {
            push(row[0], row[1], true);
          } else if (row && typeof row === "object") {
            push(row.submission_id || row.submissionId || row.paper_id, row.pc_id || row.pcId || row.reviewer_id, row.conflict !== false);
          }
        });
      } else if (payload && typeof payload === "object") {
        if (Array.isArray(payload.conflicts)) {
          return normalizeCoi(payload.conflicts);
        }
        Object.entries(payload).forEach(([subId, value]) => {
          if (Array.isArray(value)) {
            value.forEach((pcId) => push(subId, pcId, true));
          } else if (value && typeof value === "object") {
            Object.entries(value).forEach(([pcId, v]) => push(subId, pcId, Boolean(v)));
          }
        });
      }
      return set;
    }

    function runAssignment() {
      const workload = Math.max(1, Number(document.getElementById("workloadInput").value) || 1);
      const coverage = Math.max(1, Number(document.getElementById("coverageInput").value) || 1);
      const topK = Math.max(2, Number(document.getElementById("assignTopKInput").value) || 4);
      const strictCoi = document.getElementById("strictCoiInput").checked;

      state.assignment.workload = workload;
      state.assignment.coverage = coverage;
      state.assignment.topK = topK;
      state.assignment.strictCoi = strictCoi;

      const submissions = state.assignment.submissions.map((s) => ({ ...s, topicDist: submissionDist(s) }));
      const pcs = state.assignment.pcMembers.map((pc) => ({
        ...pc,
        topicDist: pcDist(pc),
        remaining: workload
      }));

      const byPaper = [];
      const scoreMap = {};

      submissions.forEach((sub) => {
        const scored = pcs.map((pc) => {
          const sim = similarity(sub.topicDist, pc.topicDist, topK);
          const isConflict = state.assignment.coi.has(keyPair(sub.submission_id, pc.pc_id));
          return { pc, sim, isConflict };
        }).sort((a, b) => b.sim - a.sim);

        const chosen = [];
        for (let i = 0; i < scored.length; i += 1) {
          const item = scored[i];
          if (chosen.length >= coverage) break;
          if (item.pc.remaining <= 0) continue;
          if (strictCoi && item.isConflict) continue;
          chosen.push(item);
          item.pc.remaining -= 1;
        }

        scoreMap[sub.submission_id] = Object.fromEntries(scored.map((x) => [x.pc.pc_id, x.sim]));

        byPaper.push({
          submission: sub,
          assigned: chosen.map((x) => ({ pc: x.pc, score: x.sim, conflict: x.isConflict })),
          requestedCoverage: coverage
        });
      });

      const byPc = pcs.map((pc) => {
        const assignedPapers = byPaper
          .filter((row) => row.assigned.some((a) => a.pc.pc_id === pc.pc_id))
          .map((row) => {
            const found = row.assigned.find((a) => a.pc.pc_id === pc.pc_id);
            return { submission: row.submission, score: found ? found.score : 0 };
          });
        return { pc, assignedPapers };
      });

      state.assignment.result = { byPaper, byPc, scoreMap, submissions, pcs };
      state.assignment.selected = null;
      renderAssignmentResults();
      refreshDiscoveryStatus();
    }

    function assignmentSummaryCards() {
      const result = state.assignment.result;
      if (!result) {
        return `
          <div class="metric"><div class="label">Submissions</div><div class="value">${state.assignment.submissions.length}</div></div>
          <div class="metric"><div class="label">PC Members</div><div class="value">${state.assignment.pcMembers.length}</div></div>
          <div class="metric"><div class="label">COI Pairs</div><div class="value">${state.assignment.coi.size}</div></div>
          <div class="metric"><div class="label">Status</div><div class="value">Not Run</div></div>
        `;
      }
      const totalRequested = result.byPaper.length * state.assignment.coverage;
      const totalAssigned = result.byPaper.reduce((acc, x) => acc + x.assigned.length, 0);
      const shortage = totalRequested - totalAssigned;
      return `
        <div class="metric"><div class="label">Submissions</div><div class="value">${result.byPaper.length}</div></div>
        <div class="metric"><div class="label">PC Members</div><div class="value">${result.byPc.length}</div></div>
        <div class="metric"><div class="label">Assigned Pairs</div><div class="value">${totalAssigned}</div></div>
        <div class="metric"><div class="label">Coverage Shortage</div><div class="value">${shortage}</div></div>
      `;
    }

    function renderAssignmentList() {
      const container = document.getElementById("assignmentListTable");
      const title = document.getElementById("assignmentListTitle");
      const result = state.assignment.result;
      if (!result) {
        title.textContent = "Result List";
        container.innerHTML = `<div class="tiny" style="padding:10px">Run assignment to generate result views.</div>`;
        return;
      }

      if (state.assignment.viewMode === "paper") {
        title.textContent = "Paper View List";
        container.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>Submission</th>
                <th>Assigned Members</th>
                <th>Coverage</th>
              </tr>
            </thead>
            <tbody>
              ${result.byPaper.map((row) => {
                const selected = state.assignment.selected && state.assignment.selected.type === "paper" && state.assignment.selected.id === row.submission.submission_id;
                return `
                  <tr class="clickable ${selected ? "selected" : ""}" data-type="paper" data-id="${row.submission.submission_id}">
                    <td><strong>${row.submission.submission_id}</strong><br><span class="tiny">${row.submission.title}</span><br><span class="tiny">Authors: ${authorsLabel(row.submission.authors)}</span></td>
                    <td>${row.assigned.map((a) => `<span class="pill">${a.pc.pc_id} - ${a.pc.name}</span>`).join("") || `<span class="badge badge-warn">None</span>`}</td>
                    <td class="mono">${row.assigned.length}/${row.requestedCoverage}</td>
                  </tr>
                `;
              }).join("")}
            </tbody>
          </table>
        `;
      } else {
        title.textContent = "PC Member View List";
        container.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>PC Member</th>
                <th>Assigned Submissions</th>
                <th>Load</th>
              </tr>
            </thead>
            <tbody>
              ${result.byPc.map((row) => {
                const selected = state.assignment.selected && state.assignment.selected.type === "pc" && state.assignment.selected.id === row.pc.pc_id;
                return `
                  <tr class="clickable ${selected ? "selected" : ""}" data-type="pc" data-id="${row.pc.pc_id}">
                    <td><strong>${row.pc.pc_id}</strong><br><span class="tiny">${row.pc.name}</span><br><span class="tiny">${row.pc.role}</span></td>
                    <td>${row.assignedPapers.map((x) => `<span class="pill">${x.submission.submission_id}</span>`).join("") || `<span class="badge badge-warn">None</span>`}</td>
                    <td class="mono">${row.assignedPapers.length}/${state.assignment.workload}</td>
                  </tr>
                `;
              }).join("")}
            </tbody>
          </table>
        `;
      }

      [...container.querySelectorAll("tr.clickable")].forEach((tr) => {
        tr.addEventListener("click", () => {
          state.assignment.selected = { type: tr.dataset.type, id: tr.dataset.id };
          renderAssignmentList();
          renderAssignmentDetail();
        });
      });
    }

    function renderAssignmentDetail() {
      const panel = document.getElementById("assignmentDetailPanel");
      const result = state.assignment.result;
      const selected = state.assignment.selected;

      if (!result || !selected) {
        panel.innerHTML = `<div class="tiny">Select a paper or PC member to inspect topic distributions and alignment explanations.</div>`;
        return;
      }

      if (selected.type === "paper") {
        const row = result.byPaper.find((x) => x.submission.submission_id === selected.id);
        if (!row) return;
        panel.innerHTML = `
          <div class="tiny"><strong>Paper:</strong> ${row.submission.submission_id} - ${row.submission.title}</div>
          <div class="tiny"><strong>Authors:</strong> ${authorsLabel(row.submission.authors)}</div>
          <div class="tiny"><strong>Topic Tags:</strong> ${topicHintsLabel(row.submission.topic_hints)}</div>
          <div style="margin-top:8px"><strong style="font-size:0.82rem">Paper Topic Distribution</strong></div>
          ${barsHtml(row.submission.topicDist)}
          <div style="margin-top:10px"><strong style="font-size:0.82rem">Assigned PC Members</strong></div>
          ${row.assigned.map((a) => `
            <div class="detail-card" style="margin-top:8px;padding:8px">
              <div class="tiny"><strong>${a.pc.name}</strong> (${a.pc.pc_id}, ${a.pc.role})  similarity <span class="mono">${formatNum(a.score, 3)}</span></div>
              ${barsHtml(a.pc.topicDist, "warm")}
            </div>
          `).join("") || `<div class="tiny">No assigned members.</div>`}
        `;
      } else {
        const row = result.byPc.find((x) => x.pc.pc_id === selected.id);
        if (!row) return;
        panel.innerHTML = `
          <div class="tiny"><strong>PC Member:</strong> ${row.pc.name} (${row.pc.pc_id}, ${row.pc.role})</div>
          <div style="margin-top:8px"><strong style="font-size:0.82rem">PC Topic Distribution</strong></div>
          ${barsHtml(row.pc.topicDist)}
          <div style="margin-top:10px"><strong style="font-size:0.82rem">Assigned Submissions</strong></div>
          ${row.assignedPapers.map((x) => `
            <div class="detail-card" style="margin-top:8px;padding:8px">
              <div class="tiny"><strong>${x.submission.submission_id}</strong> - ${x.submission.title}</div>
              <div class="tiny">Authors: ${authorsLabel(x.submission.authors)}  similarity <span class="mono">${formatNum(x.score, 3)}</span></div>
              ${barsHtml(x.submission.topicDist, "warm")}
            </div>
          `).join("") || `<div class="tiny">No assigned submissions.</div>`}
        `;
      }
    }

    function renderAssignmentResults() {
      document.getElementById("assignmentSummary").innerHTML = assignmentSummaryCards();
      document.getElementById("assignTopKValue").textContent = String(state.assignment.topK);
      document.getElementById("assignmentUploadStatus").innerHTML = `
        submissions: <span class="mono">${state.assignment.submissions.length}</span> |
        pc members: <span class="mono">${state.assignment.pcMembers.length}</span> |
        COI pairs: <span class="mono">${state.assignment.coi.size}</span>
      `;
      renderAssignmentList();
      renderAssignmentDetail();
    }

    function supplyDistByRole(role, extraCandidates = []) {
      const basePcs = state.assignment.pcMembers.filter((pc) => pc.role === role);
      const all = [...basePcs, ...extraCandidates];
      if (!all.length) {
        const zero = {};
        leafIds.forEach((l) => { zero[l] = 0; });
        return normalizeDist(zero);
      }
      const dists = all.map((pc) => pc.topicDist || pcDist(pc));
      return avgDist(dists);
    }

    function demandDistFromSubmissions() {
      if (!state.assignment.submissions.length) {
        const zero = {};
        leafIds.forEach((l) => { zero[l] = 0; });
        return normalizeDist(zero);
      }
      return avgDist(state.assignment.submissions.map((s) => s.topicDist || submissionDist(s)));
    }

    function candidatePoolFiltered() {
      return state.discovery.externalCandidates
        .filter((c) => c.source === state.discovery.source)
        .filter((c) => c.role === state.discovery.role)
        .map((c) => ({ ...c, topicDist: c.topicDist || pcDist(c) }));
    }

    function runDiscoverySearch() {
      const count = Math.max(1, Number(document.getElementById("discoveryCountInput").value) || 1);
      const role = document.getElementById("discoveryRoleSelect").value;
      const source = document.getElementById("discoverySourceSelect").value;
      state.discovery.requiredCount = count;
      state.discovery.role = role;
      state.discovery.source = source;

      const demand = demandDistFromSubmissions();
      const baseSupply = supplyDistByRole(role, []);
      let currentSupply = { ...baseSupply };
      let currentDist = treeWasserstein(demand, currentSupply);

      const pool = candidatePoolFiltered();
      const remaining = [...pool];
      const recommended = [];
      const gains = {};

      for (let i = 0; i < count && remaining.length > 0; i += 1) {
        let bestIdx = -1;
        let bestGain = -Infinity;
        let bestNewSupply = null;
        let bestNewDist = null;

        remaining.forEach((cand, idx) => {
          const trial = avgDist([currentSupply, cand.topicDist]);
          const trialDist = treeWasserstein(demand, trial);
          const gain = currentDist - trialDist;
          if (gain > bestGain) {
            bestGain = gain;
            bestIdx = idx;
            bestNewSupply = trial;
            bestNewDist = trialDist;
          }
        });

        if (bestIdx === -1) break;
        const picked = remaining.splice(bestIdx, 1)[0];
        recommended.push(picked);
        gains[picked.pc_id] = bestGain;
        currentSupply = bestNewSupply;
        currentDist = bestNewDist;
      }

      state.discovery.recommendedIds = recommended.map((x) => x.pc_id);
      state.discovery.selectedIds = new Set(state.discovery.recommendedIds);

      const afterSupply = getDiscoveryAugmentedSupply();
      state.discovery.result = {
        demand,
        baseSupply,
        afterSupply,
        beforeDist: treeWasserstein(demand, baseSupply),
        afterDist: treeWasserstein(demand, afterSupply),
        gains,
        pool
      };
      renderDiscoveryResults();
    }

    function getDiscoverySelectedCandidates() {
      const pool = candidatePoolFiltered();
      const set = state.discovery.selectedIds;
      return pool.filter((c) => set.has(c.pc_id));
    }

    function getDiscoveryAugmentedSupply() {
      const role = state.discovery.role;
      const selected = getDiscoverySelectedCandidates();
      return supplyDistByRole(role, selected);
    }

    function gapBarsHtml(demand, supply, title) {
      const rows = leafIds.map((leaf) => ({
        leaf,
        demand: demand[leaf],
        supply: supply[leaf],
        gap: demand[leaf] - supply[leaf]
      })).sort((a, b) => Math.abs(b.gap) - Math.abs(a.gap));

      const maxGap = Math.max(0.0001, ...rows.map((r) => Math.abs(r.gap)));
      return `
        <div class="detail-card" style="margin-top:8px;padding:8px">
          <div class="tiny"><strong>${title}</strong></div>
          <div class="bars" style="margin-top:6px">
            ${rows.map((r) => `
              <div class="bar-row">
                <div>${byId[r.leaf].label}</div>
                <div class="bar-track"><div class="bar-fill ${r.gap >= 0 ? "warm" : "muted"}" style="width:${(Math.abs(r.gap) / maxGap * 100).toFixed(2)}%"></div></div>
                <div class="mono">${r.gap >= 0 ? "+" : ""}${formatNum(r.gap, 3)}</div>
              </div>
            `).join("")}
          </div>
        </div>
      `;
    }

    function renderDiscoveryResults() {
      const status = document.getElementById("discoveryInputStatus");
      status.innerHTML = `
        submissions in demand set: <span class="mono">${state.assignment.submissions.length}</span><br>
        current PC members: <span class="mono">${state.assignment.pcMembers.length}</span><br>
        source: <span class="mono">${state.discovery.source}</span>  role: <span class="mono">${state.discovery.role}</span>
      `;

      const result = state.discovery.result;
      const gapPanel = document.getElementById("discoveryGapPanel");
      const tablePanel = document.getElementById("discoveryCandidateTable");

      if (!result) {
        gapPanel.innerHTML = `<div class="tiny">Run search to compute current and augmented gap.</div>`;
        tablePanel.innerHTML = `<div class="tiny" style="padding:10px">No candidate list yet.</div>`;
        return;
      }

      const afterSupply = getDiscoveryAugmentedSupply();
      const beforeDist = treeWasserstein(result.demand, result.baseSupply);
      const afterDist = treeWasserstein(result.demand, afterSupply);

      gapPanel.innerHTML = `
        <div class="summary">
          <div class="metric"><div class="label">Before TWD</div><div class="value">${formatNum(beforeDist, 3)}</div></div>
          <div class="metric"><div class="label">After TWD</div><div class="value">${formatNum(afterDist, 3)}</div></div>
          <div class="metric"><div class="label">Reduction</div><div class="value">${formatNum(beforeDist - afterDist, 3)}</div></div>
          <div class="metric"><div class="label">Selected Candidates</div><div class="value">${state.discovery.selectedIds.size}</div></div>
        </div>
        ${gapBarsHtml(result.demand, result.baseSupply, "Current Gap")}
        ${gapBarsHtml(result.demand, afterSupply, "Gap After Selected Candidates")}
      `;

      const pool = result.pool
        .map((c) => ({
          ...c,
          selected: state.discovery.selectedIds.has(c.pc_id),
          recommended: state.discovery.recommendedIds.includes(c.pc_id),
          gain: result.gains[c.pc_id] || 0
        }))
        .sort((a, b) => Number(b.recommended) - Number(a.recommended) || b.gain - a.gain);

      tablePanel.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Select</th>
              <th>Candidate</th>
              <th>Source</th>
              <th>Role</th>
              <th>Estimated Gain</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            ${pool.map((c) => `
              <tr>
                <td><input type="checkbox" data-cand-id="${c.pc_id}" ${c.selected ? "checked" : ""}></td>
                <td><strong>${c.name || c.pc_id}</strong><br><span class="tiny">${c.pc_id}</span></td>
                <td>${c.source}</td>
                <td>${c.role}</td>
                <td class="mono">${formatNum(c.gain, 3)}</td>
                <td>${c.recommended ? `<span class="badge badge-ok">Recommended</span>` : `<span class="badge badge-muted">Candidate</span>`}</td>
              </tr>
            `).join("") || `<tr><td colspan="6" class="tiny">No candidates from selected source + role.</td></tr>`}
          </tbody>
        </table>
      `;

      [...tablePanel.querySelectorAll('input[type="checkbox"][data-cand-id]')].forEach((cb) => {
        cb.addEventListener("change", () => {
          const id = cb.getAttribute("data-cand-id");
          if (cb.checked) state.discovery.selectedIds.add(id);
          else state.discovery.selectedIds.delete(id);
          renderDiscoveryResults();
        });
      });
    }

    function scheduleSessionId(slot, track) {
      return `slot_${slot}_track_${track}`;
    }

    function parseSessionId(sessionId) {
      const m = /slot_(\d+)_track_(\d+)/.exec(sessionId);
      if (!m) return { slot: 0, track: 0 };
      return { slot: Number(m[1]), track: Number(m[2]) };
    }

    function runOralOrganization() {
      state.oral.parallelSessions = Math.max(1, Number(document.getElementById("oralParallelInput").value) || 1);
      state.oral.maxPerSession = Math.max(1, Number(document.getElementById("oralMaxInput").value) || 1);
      state.oral.timeSlots = Math.max(1, Number(document.getElementById("oralSlotsInput").value) || 1);

      const papers = state.oral.papers.map((p) => ({ ...p, topicDist: submissionDist(p) }));
      const K = state.oral.parallelSessions;
      const T = state.oral.timeSlots;
      const C = state.oral.maxPerSession;

      const sessions = [];
      for (let t = 1; t <= T; t += 1) {
        for (let k = 1; k <= K; k += 1) {
          sessions.push({
            id: scheduleSessionId(t, k),
            slot: t,
            track: k,
            papers: [],
            centroid: null
          });
        }
      }

      const ordered = [...papers].sort((a, b) => {
        const da = topTopicEntries(a.topicDist, 1)[0].v;
        const db = topTopicEntries(b.topicDist, 1)[0].v;
        return db - da;
      });

      const unassigned = [];
      const assignment = {};

      ordered.forEach((paper) => {
        let best = null;
        let bestCost = Infinity;
        sessions.forEach((s) => {
          if (s.papers.length >= C) return;
          const cost = s.centroid ? treeWasserstein(s.centroid, paper.topicDist) : 0;
          if (cost < bestCost) {
            bestCost = cost;
            best = s;
          }
        });
        if (!best) {
          unassigned.push(paper);
          assignment[paper.submission_id] = null;
          return;
        }
        best.papers.push(paper);
        best.centroid = avgDist(best.papers.map((x) => x.topicDist));
        assignment[paper.submission_id] = best.id;
      });

      state.oral.result = { sessions, unassigned, assignment, papers };
      renderOralResults();
    }

    function setOralAssignment(paperId, sessionId) {
      const result = state.oral.result;
      if (!result) return;

      const paper = result.papers.find((p) => p.submission_id === paperId);
      if (!paper) return;

      result.sessions.forEach((s) => {
        s.papers = s.papers.filter((p) => p.submission_id !== paperId);
        s.centroid = s.papers.length ? avgDist(s.papers.map((x) => x.topicDist)) : null;
      });
      result.unassigned = result.unassigned.filter((p) => p.submission_id !== paperId);

      if (!sessionId) {
        result.unassigned.push(paper);
        result.assignment[paperId] = null;
        renderOralResults();
        return;
      }

      const target = result.sessions.find((s) => s.id === sessionId);
      if (!target) return;
      if (target.papers.length >= state.oral.maxPerSession) {
        alert("Selected session is full.");
        renderOralResults();
        return;
      }

      target.papers.push(paper);
      target.centroid = avgDist(target.papers.map((x) => x.topicDist));
      result.assignment[paperId] = sessionId;
      renderOralResults();
    }

    function renderOralResults() {
      const summary = document.getElementById("oralSummary");
      const schedulePanel = document.getElementById("oralSchedulePanel");
      const editorPanel = document.getElementById("oralEditorPanel");

      const result = state.oral.result;
      document.getElementById("oralUploadStatus").innerHTML = `oral papers loaded: <span class="mono">${state.oral.papers.length}</span>`;

      if (!result) {
        summary.innerHTML = `
          <div class="metric"><div class="label">Papers</div><div class="value">${state.oral.papers.length}</div></div>
          <div class="metric"><div class="label">Parallel Sessions</div><div class="value">${state.oral.parallelSessions}</div></div>
          <div class="metric"><div class="label">Time Slots</div><div class="value">${state.oral.timeSlots}</div></div>
          <div class="metric"><div class="label">Status</div><div class="value">Not Run</div></div>
        `;
        schedulePanel.innerHTML = `<div class="tiny" style="padding:10px">Run oral organization to generate schedule table.</div>`;
        editorPanel.innerHTML = `<div class="tiny" style="padding:10px">Manual editor appears after run.</div>`;
        return;
      }

      summary.innerHTML = `
        <div class="metric"><div class="label">Papers</div><div class="value">${result.papers.length}</div></div>
        <div class="metric"><div class="label">Sessions</div><div class="value">${result.sessions.length}</div></div>
        <div class="metric"><div class="label">Unassigned</div><div class="value">${result.unassigned.length}</div></div>
        <div class="metric"><div class="label">Capacity</div><div class="value">${state.oral.maxPerSession}</div></div>
      `;

      const T = state.oral.timeSlots;
      const K = state.oral.parallelSessions;

      schedulePanel.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Time Slot</th>
              ${Array.from({ length: K }, (_, i) => `<th>Track ${i + 1}</th>`).join("")}
            </tr>
          </thead>
          <tbody>
            ${Array.from({ length: T }, (_, tIdx) => {
              const slot = tIdx + 1;
              return `
                <tr>
                  <td><strong>Slot ${slot}</strong></td>
                  ${Array.from({ length: K }, (_, kIdx) => {
                    const track = kIdx + 1;
                    const sessionId = scheduleSessionId(slot, track);
                    const session = result.sessions.find((s) => s.id === sessionId);
                    const pills = session.papers.map((p) => `<span class="pill">${p.submission_id}: ${p.title}</span>`).join("") || `<span class="tiny">(empty)</span>`;
                    return `<td><div class="schedule-cell">${pills}</div></td>`;
                  }).join("")}
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;

      editorPanel.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Paper</th>
              <th>Current Assignment</th>
              <th>Move To Session</th>
            </tr>
          </thead>
          <tbody>
            ${result.papers.map((p) => {
              const cur = result.assignment[p.submission_id];
              const curTxt = cur ? (() => {
                const pos = parseSessionId(cur);
                return `Slot ${pos.slot} / Track ${pos.track}`;
              })() : "Unassigned";

              return `
                <tr>
                  <td><strong>${p.submission_id}</strong><br><span class="tiny">${p.title}</span></td>
                  <td>${curTxt}</td>
                  <td>
                    <select data-oral-paper="${p.submission_id}">
                      <option value="">Unassigned</option>
                      ${result.sessions.map((s) => `<option value="${s.id}" ${cur === s.id ? "selected" : ""}>Slot ${s.slot} / Track ${s.track}</option>`).join("")}
                    </select>
                  </td>
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;

      [...editorPanel.querySelectorAll("select[data-oral-paper]")].forEach((sel) => {
        sel.addEventListener("change", () => {
          const paperId = sel.getAttribute("data-oral-paper");
          const sessionId = sel.value || null;
          setOralAssignment(paperId, sessionId);
        });
      });
    }

    function runPosterOrganization() {
      state.poster.rows = Math.max(1, Number(document.getElementById("posterRowsInput").value) || 1);
      state.poster.cols = Math.max(1, Number(document.getElementById("posterColsInput").value) || 1);
      state.poster.sessionCount = Math.max(1, Number(document.getElementById("posterSessionCountInput").value) || 1);

      const papers = state.poster.papers.map((p) => ({ ...p, topicDist: submissionDist(p) }));
      const rows = state.poster.rows;
      const cols = state.poster.cols;
      const sessionCount = state.poster.sessionCount;
      const capacity = rows * cols;

      const sessions = Array.from({ length: sessionCount }, (_, idx) => ({
        id: `poster_session_${idx + 1}`,
        index: idx + 1,
        cells: Array.from({ length: capacity }, () => null)
      }));

      const placements = {};
      const unassigned = [];

      const ordered = [...papers].sort((a, b) => topTopicEntries(b.topicDist, 1)[0].v - topTopicEntries(a.topicDist, 1)[0].v);

      ordered.forEach((paper) => {
        let target = null;
        for (let i = 0; i < sessions.length; i += 1) {
          const s = sessions[i];
          const idx = s.cells.findIndex((x) => x === null);
          if (idx !== -1) {
            target = { session: s, cell: idx };
            break;
          }
        }

        if (!target) {
          unassigned.push(paper);
          placements[paper.submission_id] = null;
          return;
        }

        target.session.cells[target.cell] = paper;
        placements[paper.submission_id] = { sessionId: target.session.id, cellIndex: target.cell };
      });

      state.poster.result = { sessions, placements, papers, unassigned };
      renderPosterResults();
    }

    function firstEmptyCell(session) {
      return session.cells.findIndex((x) => x === null);
    }

    function setPosterPlacement(paperId, targetSessionId, targetCellIndex) {
      const result = state.poster.result;
      if (!result) return;
      const paper = result.papers.find((p) => p.submission_id === paperId);
      if (!paper) return;

      const oldPlacement = result.placements[paperId];
      if (oldPlacement) {
        const oldSession = result.sessions.find((s) => s.id === oldPlacement.sessionId);
        if (oldSession) oldSession.cells[oldPlacement.cellIndex] = null;
      }
      result.unassigned = result.unassigned.filter((p) => p.submission_id !== paperId);

      if (!targetSessionId || targetCellIndex === null || targetCellIndex === undefined || targetCellIndex === "") {
        result.placements[paperId] = null;
        result.unassigned.push(paper);
        renderPosterResults();
        return;
      }

      const targetSession = result.sessions.find((s) => s.id === targetSessionId);
      if (!targetSession) return;
      const cellIdx = Number(targetCellIndex);
      const occupant = targetSession.cells[cellIdx];

      if (occupant && occupant.submission_id !== paperId) {
        const freeIdx = firstEmptyCell(targetSession);
        if (freeIdx !== -1) {
          targetSession.cells[freeIdx] = occupant;
          result.placements[occupant.submission_id] = { sessionId: targetSession.id, cellIndex: freeIdx };
        } else {
          result.unassigned.push(occupant);
          result.placements[occupant.submission_id] = null;
        }
      }

      targetSession.cells[cellIdx] = paper;
      result.placements[paperId] = { sessionId: targetSession.id, cellIndex: cellIdx };
      renderPosterResults();
    }

    function renderPosterResults() {
      const summary = document.getElementById("posterSummary");
      const gridPanel = document.getElementById("posterGridPanel");
      const editorPanel = document.getElementById("posterEditorPanel");

      const result = state.poster.result;
      document.getElementById("posterUploadStatus").innerHTML = `poster papers loaded: <span class="mono">${state.poster.papers.length}</span>`;

      if (!result) {
        summary.innerHTML = `
          <div class="metric"><div class="label">Papers</div><div class="value">${state.poster.papers.length}</div></div>
          <div class="metric"><div class="label">Grid</div><div class="value">${state.poster.rows} x ${state.poster.cols}</div></div>
          <div class="metric"><div class="label">Sessions</div><div class="value">${state.poster.sessionCount}</div></div>
          <div class="metric"><div class="label">Status</div><div class="value">Not Run</div></div>
        `;
        gridPanel.innerHTML = `<div class="tiny">Run poster organization to generate arrangement table.</div>`;
        editorPanel.innerHTML = `<div class="tiny">Manual editor appears after run.</div>`;
        return;
      }

      summary.innerHTML = `
        <div class="metric"><div class="label">Papers</div><div class="value">${result.papers.length}</div></div>
        <div class="metric"><div class="label">Grid</div><div class="value">${state.poster.rows} x ${state.poster.cols}</div></div>
        <div class="metric"><div class="label">Sessions</div><div class="value">${result.sessions.length}</div></div>
        <div class="metric"><div class="label">Unassigned</div><div class="value">${result.unassigned.length}</div></div>
      `;

      gridPanel.innerHTML = result.sessions.map((session) => {
        return `
          <div class="poster-grid" style="margin-bottom:10px">
            <div style="padding:8px 10px;border-bottom:1px solid #e9f1ee;background:#f7fbfa"><strong>Session ${session.index}</strong></div>
            <table>
              <tbody>
                ${Array.from({ length: state.poster.rows }, (_, r) => {
                  return `
                    <tr>
                      ${Array.from({ length: state.poster.cols }, (_, c) => {
                        const idx = r * state.poster.cols + c;
                        const paper = session.cells[idx];
                        return `
                          <td class="poster-cell">
                            ${paper ? `<strong>${paper.submission_id}</strong><br><span class="tiny">${paper.title}</span>` : `<span class="tiny">(empty)</span>`}
                          </td>
                        `;
                      }).join("")}
                    </tr>
                  `;
                }).join("")}
              </tbody>
            </table>
          </div>
        `;
      }).join("") + (result.unassigned.length ? `<div class="tiny">Unassigned: ${result.unassigned.map((p) => p.submission_id).join(", ")}</div>` : "");

      const cellOptions = Array.from({ length: state.poster.rows * state.poster.cols }, (_, idx) => `<option value="${idx}">Cell ${idx + 1}</option>`).join("");

      editorPanel.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Paper</th>
              <th>Current Assignment</th>
              <th>Session</th>
              <th>Cell</th>
            </tr>
          </thead>
          <tbody>
            ${result.papers.map((p) => {
              const place = result.placements[p.submission_id];
              const curText = place
                ? `Session ${Number(place.sessionId.split("_").pop())}, Cell ${place.cellIndex + 1}`
                : "Unassigned";
              return `
                <tr>
                  <td><strong>${p.submission_id}</strong><br><span class="tiny">${p.title}</span></td>
                  <td>${curText}</td>
                  <td>
                    <select data-poster-paper="${p.submission_id}" data-field="session">
                      <option value="">Unassigned</option>
                      ${result.sessions.map((s) => `<option value="${s.id}" ${place && place.sessionId === s.id ? "selected" : ""}>Session ${s.index}</option>`).join("")}
                    </select>
                  </td>
                  <td>
                    <select data-poster-paper="${p.submission_id}" data-field="cell">
                      ${place ? cellOptions.replace(`value=\"${place.cellIndex}\"`, `value=\"${place.cellIndex}\" selected`) : `<option value="">n/a</option>${cellOptions}`}
                    </select>
                  </td>
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;

      [...editorPanel.querySelectorAll('select[data-poster-paper][data-field="session"]')].forEach((sel) => {
        sel.addEventListener("change", () => {
          const paperId = sel.getAttribute("data-poster-paper");
          const row = sel.closest("tr");
          const cellSel = row.querySelector('select[data-field="cell"]');
          const sessionId = sel.value || null;
          const cellIdx = sessionId ? Number(cellSel.value) : null;
          setPosterPlacement(paperId, sessionId, sessionId ? cellIdx : null);
        });
      });

      [...editorPanel.querySelectorAll('select[data-poster-paper][data-field="cell"]')].forEach((sel) => {
        sel.addEventListener("change", () => {
          const paperId = sel.getAttribute("data-poster-paper");
          const row = sel.closest("tr");
          const sessionSel = row.querySelector('select[data-field="session"]');
          const sessionId = sessionSel.value || null;
          if (!sessionId) {
            alert("Select a session first.");
            renderPosterResults();
            return;
          }
          setPosterPlacement(paperId, sessionId, Number(sel.value));
        });
      });
    }

    function downloadJson(filename, obj) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function refreshDiscoveryStatus() {
      document.getElementById("discoveryInputStatus").innerHTML = `
        submissions in demand set: <span class="mono">${state.assignment.submissions.length}</span><br>
        current PC members: <span class="mono">${state.assignment.pcMembers.length}</span><br>
        source: <span class="mono">${state.discovery.source}</span>  role: <span class="mono">${state.discovery.role}</span>
      `;
    }

    function switchTask(task) {
      state.activeTask = task;
      [...document.querySelectorAll(".nav-btn")].forEach((btn) => {
        btn.classList.toggle("is-active", btn.dataset.task === task);
      });
      [...document.querySelectorAll(".task-view")].forEach((view) => {
        view.classList.toggle("is-active", view.id === `task-${task}`);
      });
    }

    function setupEvents() {
      [...document.querySelectorAll(".nav-btn")].forEach((btn) => {
        btn.addEventListener("click", () => switchTask(btn.dataset.task));
      });

      document.getElementById("paperViewBtn").addEventListener("click", () => {
        state.assignment.viewMode = "paper";
        document.getElementById("paperViewBtn").classList.add("is-active");
        document.getElementById("pcViewBtn").classList.remove("is-active");
        renderAssignmentList();
        renderAssignmentDetail();
      });

      document.getElementById("pcViewBtn").addEventListener("click", () => {
        state.assignment.viewMode = "pc";
        document.getElementById("pcViewBtn").classList.add("is-active");
        document.getElementById("paperViewBtn").classList.remove("is-active");
        renderAssignmentList();
        renderAssignmentDetail();
      });

      document.getElementById("assignTopKInput").addEventListener("input", (e) => {
        document.getElementById("assignTopKValue").textContent = String(e.target.value);
      });

      document.getElementById("runAssignmentBtn").addEventListener("click", runAssignment);

      document.getElementById("uploadSubmissionBtn").addEventListener("click", () => {
        document.getElementById("submissionFileInput").click();
      });
      document.getElementById("submissionFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          const rows = normalizeSubmissionList(payload);
          if (!rows.length) {
            alert("No valid submissions found in file.");
            return;
          }
          state.assignment.submissions = rows;
          state.assignment.result = null;
          renderAssignmentResults();
          refreshDiscoveryStatus();
        });
        e.target.value = "";
      });

      document.getElementById("uploadPcBtn").addEventListener("click", () => {
        document.getElementById("pcFileInput").click();
      });
      document.getElementById("pcFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          const rows = normalizePcList(payload);
          if (!rows.length) {
            alert("No valid PC members found in file.");
            return;
          }
          state.assignment.pcMembers = rows;
          state.assignment.result = null;
          renderAssignmentResults();
          refreshDiscoveryStatus();
        });
        e.target.value = "";
      });

      document.getElementById("uploadCoiBtn").addEventListener("click", () => {
        document.getElementById("coiFileInput").click();
      });
      document.getElementById("coiFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          state.assignment.coi = normalizeCoi(payload);
          state.assignment.result = null;
          renderAssignmentResults();
        });
        e.target.value = "";
      });

      document.getElementById("discoverySourceSelect").addEventListener("change", (e) => {
        state.discovery.source = e.target.value;
        refreshDiscoveryStatus();
      });
      document.getElementById("discoveryRoleSelect").addEventListener("change", (e) => {
        state.discovery.role = e.target.value;
        refreshDiscoveryStatus();
      });
      document.getElementById("runDiscoveryBtn").addEventListener("click", runDiscoverySearch);

      document.getElementById("uploadOralPapersBtn").addEventListener("click", () => {
        document.getElementById("oralFileInput").click();
      });
      document.getElementById("oralFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          const rows = normalizeSubmissionList(payload);
          if (!rows.length) {
            alert("No valid oral papers found in file.");
            return;
          }
          state.oral.papers = rows;
          state.oral.result = null;
          renderOralResults();
        });
        e.target.value = "";
      });

      document.getElementById("runOralBtn").addEventListener("click", runOralOrganization);
      document.getElementById("exportOralBtn").addEventListener("click", () => {
        if (!state.oral.result) {
          alert("Run oral organization first.");
          return;
        }
        const output = {
          task: "oral_session_organization",
          parameters: {
            parallel_sessions: state.oral.parallelSessions,
            max_papers_per_session: state.oral.maxPerSession,
            time_slots: state.oral.timeSlots
          },
          assignments: state.oral.result.papers.map((p) => {
            const sid = state.oral.result.assignment[p.submission_id];
            if (!sid) return { paper_id: p.submission_id, session: null };
            const pos = parseSessionId(sid);
            return { paper_id: p.submission_id, session: { time_slot: pos.slot, track: pos.track } };
          })
        };
        downloadJson("oral_organization_result.json", output);
      });

      document.getElementById("uploadPosterPapersBtn").addEventListener("click", () => {
        document.getElementById("posterFileInput").click();
      });
      document.getElementById("posterFileInput").addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        parseJsonFile(file, (payload) => {
          const rows = normalizeSubmissionList(payload);
          if (!rows.length) {
            alert("No valid poster papers found in file.");
            return;
          }
          state.poster.papers = rows;
          state.poster.result = null;
          renderPosterResults();
        });
        e.target.value = "";
      });

      document.getElementById("runPosterBtn").addEventListener("click", runPosterOrganization);
      document.getElementById("exportPosterBtn").addEventListener("click", () => {
        if (!state.poster.result) {
          alert("Run poster organization first.");
          return;
        }
        const output = {
          task: "poster_session_organization",
          parameters: {
            rows: state.poster.rows,
            cols: state.poster.cols,
            session_count: state.poster.sessionCount
          },
          assignments: state.poster.result.papers.map((p) => {
            const place = state.poster.result.placements[p.submission_id];
            if (!place) return { paper_id: p.submission_id, assignment: null };
            const sessionNumber = Number(place.sessionId.split("_").pop());
            const row = Math.floor(place.cellIndex / state.poster.cols) + 1;
            const col = (place.cellIndex % state.poster.cols) + 1;
            return {
              paper_id: p.submission_id,
              assignment: {
                session: sessionNumber,
                row,
                col
              }
            };
          })
        };
        downloadJson("poster_organization_result.json", output);
      });
    }

    function init() {
      setupEvents();
      renderAssignmentResults();
      renderDiscoveryResults();
      renderOralResults();
      renderPosterResults();
      refreshDiscoveryStatus();
    }

    init();
  </script>
</body>
</html>
